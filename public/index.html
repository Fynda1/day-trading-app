<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fynda Auto Trading BOT</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #0f1419 0%, #1a202c 50%, #2d3748 100%);
            color: white; padding: 10px; min-height: 100vh;
        }
        .container {
            max-width: 1400px; margin: 0 auto;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px; padding: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }
        .header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 20px; padding-bottom: 15px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }
        h1 { font-size: 2.2em; color: #4facfe; }
        .connection-status {
            padding: 8px 16px; border-radius: 20px;
            font-size: 14px; font-weight: bold;
        }
        .connection-online { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
        .connection-offline { background: rgba(239, 68, 68, 0.2); color: #ef4444; }

        .main-grid {
            display: grid; grid-template-columns: 300px 1fr 260px 220px 220px; gap: 10px;
            margin-bottom: 20px;
        }

        .left-panel, .center-panel, .right-panel, .watchlist-panel, .scanner-panel {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px; padding: 15px;
        }

        .section-title {
            font-size: 1.3em; margin-bottom: 15px; color: #e2e8f0;
            border-bottom: 2px solid rgba(79, 172, 254, 0.3); padding-bottom: 8px;
        }

        .form-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 6px; font-weight: 600; color: #cbd5e0; }

        select, input, textarea {
            width: 100%; padding: 10px; border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px; background: rgba(255, 255, 255, 0.9);
            color: #1a202c; font-size: 14px;
        }
        select option { background: #2d3748; color: white; }

        .button-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 12px; }
        .button-row { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; margin-top: 8px; }

        .btn {
            padding: 12px 20px; border: none; border-radius: 8px;
            font-size: 13px; font-weight: 600; cursor: pointer;
            text-transform: uppercase; letter-spacing: 0.5px;
        }
        .btn-buy { background: #10b981; color: white; }
        .btn-sell { background: #ef4444; color: white; }
        .btn-cancel { background: #f59e0b; color: white; }
        .btn-primary { background: #3b82f6; color: white; }
        .btn-secondary { background: #6366f1; color: white; }
        .btn-success { background: #22c55e; color: white; }
        .btn-danger { background: #ef4444; color: white; }

        .automation-panel {
            background: rgba(16, 185, 129, 0.1);
            border-radius: 10px; padding: 15px; margin-top: 15px;
        }
        .automation-status {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 10px;
        }
        .status-indicator {
            width: 12px; height: 12px; border-radius: 50%;
        }
        .status-active { background: #22c55e; }
        .status-inactive { background: #6b7280; }

        .chart-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px; padding: 15px; margin-bottom: 15px;
            height: 300px; position: relative;
        }

        .chart-controls { display: flex; gap: 8px; margin-bottom: 10px; }
        .chart-btn {
            padding: 6px 12px; border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1); color: white;
            border-radius: 6px; cursor: pointer; font-size: 12px;
        }
        .chart-btn.active { background: #4facfe; }

        .indicators-grid {
            display: grid; grid-template-columns: repeat(3, 1fr);
            gap: 12px; margin-bottom: 15px;
        }
        .indicator-card {
            background: rgba(255, 255, 255, 0.08); padding: 12px;
            border-radius: 8px; text-align: center;
        }
        .indicator-value { font-size: 18px; font-weight: bold; margin-bottom: 4px; }
        .indicator-label { font-size: 11px; opacity: 0.8; }

        .pnl-display {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 10px; padding: 15px; margin-bottom: 15px;
        }
        .pnl-value { font-size: 24px; font-weight: bold; text-align: center; margin-bottom: 8px; }
        .pnl-positive { color: #22c55e; }
        .pnl-negative { color: #ef4444; }

        .trades-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px; padding: 15px; margin-bottom: 15px;
            max-height: 200px; overflow-y: auto;
        }
        .trade-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 8px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 12px;
        }

        .logs-panel {
            background: rgba(0, 0, 0, 0.3); border-radius: 8px;
            padding: 15px; height: 250px; overflow-y: auto;
            font-family: monospace; font-size: 11px;
            display: none;
        }
        .log-entry { margin-bottom: 4px; padding: 2px 0; }
        .log-info { color: #60a5fa; }
        .log-success { color: #34d399; }
        .log-warning { color: #fbbf24; }
        .log-error { color: #f87171; }

        .signal-display {
            text-align: center; padding: 15px; border-radius: 10px;
            font-size: 20px; font-weight: bold; margin-bottom: 15px;
        }
        .signal-buy { background: #10b981; }
        .signal-sell { background: #ef4444; }
        .signal-hold { background: #f59e0b; }

        .watchlist-panel {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px; padding: 15px;
            border: 2px solid rgba(79, 172, 254, 0.3);
        }

        .watchlist-container {
            max-height: 500px; overflow-y: auto;
        }

        .watchlist-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px; padding: 10px; margin-bottom: 8px;
            cursor: pointer; transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .watchlist-item:hover {
            background: rgba(79, 172, 254, 0.2);
            border-color: #4facfe;
        }
        .watchlist-item.selected {
            background: rgba(79, 172, 254, 0.3);
            border-color: #4facfe;
        }

        .watchlist-ticker {
            font-weight: bold; font-size: 14px; margin-bottom: 4px;
            color: #4facfe;
        }
        .watchlist-price {
            font-size: 16px; font-weight: bold; margin-bottom: 2px;
        }
        .watchlist-change {
            font-size: 11px; margin-bottom: 2px;
        }
        .watchlist-volume {
            font-size: 10px; opacity: 0.8;
        }
        .price-up { color: #22c55e; }
        .price-down { color: #ef4444; }
        .price-neutral { color: #fbbf24; }

        .watchlist-controls {
            display: flex; gap: 8px; margin-bottom: 12px;
        }
        .scanner-panel {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px; padding: 15px;
            border: 3px solid rgba(34, 197, 94, 0.5);
            box-shadow: 0 0 20px rgba(34, 197, 94, 0.2);
        }

        .scanner-container {
            max-height: 400px; overflow-y: auto;
        }

        .scanner-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px; padding: 10px; margin-bottom: 8px;
            cursor: pointer; transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .scanner-item:hover {
            background: rgba(34, 197, 94, 0.2);
            border-color: #22c55e;
        }
        .scanner-item.hot {
            background: rgba(34, 197, 94, 0.15);
            border-color: #22c55e;
            animation: pulse-green 2s infinite;
        }

        @keyframes pulse-green {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .scanner-ticker {
            font-weight: bold; font-size: 14px; margin-bottom: 4px;
            color: #22c55e;
        }
        .scanner-code-area {
            height: 80px; font-family: monospace; font-size: 10px;
            margin-bottom: 8px; line-height: 1.3;
        }

        .scanner-controls {
            display: flex; flex-direction: column; gap: 6px; margin-bottom: 10px;
        }
        .scanner-btn {
            padding: 8px 12px; font-size: 11px; border: none;
            border-radius: 6px; cursor: pointer; background: #22c55e;
            color: white;
        }
        .btn-warning { background: #f59e0b; color: white; }
        .status-warning { background: #f59e0b; }
        .status-emergency { background: #dc2626; animation: pulse-red 1s infinite; }

        @keyframes pulse-red {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        .scan-status {
            font-size: 11px; margin-bottom: 8px; padding: 6px;
            background: rgba(34, 197, 94, 0.1); border-radius: 4px;
        }

        .watchlist-btn, .scanner-btn {
            padding: 4px 8px; font-size: 9px; border: none;
            border-radius: 4px; cursor: pointer; color: white;
        }
        .watchlist-btn { background: #4facfe; flex: 1; }
        .scanner-btn { background: #22c55e; }

        .scanner-btn.scanning {
            background: #f59e0b;
            animation: pulse 1s infinite;
        }

        .custom-script-area { height: 200px; font-family: monospace; font-size: 11px; line-height: 1.3; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @media (max-width: 1800px) {
            .main-grid { grid-template-columns: 280px 1fr 240px 200px 200px; gap: 8px; }
        }
        @media (max-width: 1600px) {
            .main-grid { grid-template-columns: 260px 1fr 220px 180px 180px; gap: 6px; }
            .left-panel, .right-panel, .watchlist-panel, .scanner-panel { padding: 15px; }
        }
        @media (max-width: 1400px) {
            .main-grid {
                grid-template-columns: 1fr 1fr;
                grid-template-rows: auto auto auto;
            }
            .center-panel { grid-column: 1 / -1; }
            .left-panel { grid-row: 2; }
            .right-panel { grid-row: 2; }
            .watchlist-panel {
                grid-column: 1 / -1;
                grid-row: 3;
                max-height: 200px;
            }
            .scanner-panel {
                grid-column: 1 / -1;
                grid-row: 4;
                max-height: 250px;
            }
            .watchlist-container, .scanner-container {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 8px;
                max-height: 120px;
            }
        }

        function toggleHoldMode() {
            isHoldMode = !isHoldMode;
            var holdBtn = document.getElementById('holdBtn');
            var holdStatus = document.getElementById('holdStatus');
            var holdStatusText = document.getElementById('holdStatusText');

            if (isHoldMode) {
                holdBtn.textContent = 'Resume';
                holdBtn.className = 'btn btn-warning';
                holdStatus.className = 'status-indicator status-warning';
                holdStatusText.textContent = 'HOLD Mode';
                addLog('HOLD mode activated - No new positions will be opened', 'warning');

                # Stop auto trading if active
                if (isAutoTrading) {
                    addLog('Auto trading paused due to HOLD mode', 'warning');
                }
            } else {
                holdBtn.textContent = 'HOLD';
                holdBtn.className = 'btn btn-primary';
                holdStatus.className = 'status-indicator status-inactive';
                holdStatusText.textContent = 'Trading';
                addLog('HOLD mode deactivated - Trading resumed', 'success');
            }
        }

        function closeAllPositions() {
            if (activeTrades.length === 0) {
                alert('No open positions to close');
                return;
            }

            var confirmClose = confirm('Close ALL open positions immediately?\\nThis will execute market sells for all holdings.');
            if (!confirmClose) return;

            addLog('Closing all positions - Emergency exit initiated', 'warning');

            var openTrades = activeTrades.filter(function(trade) {
                return trade.status === 'OPEN';
            });

            for (var i = 0; i < openTrades.length; i++) {
                var trade = openTrades[i];
                addLog('Emergency close: Selling ' + trade.quantity + ' shares of ' + trade.symbol, 'warning');

                # Mark trade as closed and calculate P&L
                trade.status = 'CLOSED';
                trade.exitPrice = indicators.currentPrice || trade.entryPrice;
                var profit = (trade.exitPrice - trade.entryPrice) * trade.quantity;
                realizedPnL += profit;

                # Execute actual sell order
                executeSellOrder(trade.symbol, trade.quantity);
            }

            updateActiveTradesDisplay();
            updatePnLDisplay();
            addLog('All positions closed. Total P&L impact:
        @media (max-width: 1200px) {
            .main-grid { grid-template-columns: 1fr; }
            .watchlist-panel {
                order: 3;
                max-height: 180px;
            }
            .scanner-panel {
                order: 4;
                max-height: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Fynda Auto Trading BOT</h1>
            <div class="connection-status" id="connectionStatus">Connecting...</div>
        </div>

        <div class="main-grid">
            <div class="left-panel">
                <div class="section-title">Trading Controls</div>

                <div class="form-group">
                    <label for="ticker">Select Stock:</label>
                    <select id="ticker" required>
                        <option value="">Choose a stock...</option>
                        <option value="AAPL">Apple Inc. (AAPL)</option>
                        <option value="GOOGL">Alphabet Inc. (GOOGL)</option>
                        <option value="MSFT">Microsoft Corp. (MSFT)</option>
                        <option value="AMZN">Amazon.com Inc. (AMZN)</option>
                        <option value="TSLA">Tesla Inc. (TSLA)</option>
                        <option value="META">Meta Platforms (META)</option>
                        <option value="NVDA">NVIDIA Corp. (NVDA)</option>
                        <option value="NFLX">Netflix Inc. (NFLX)</option>
                        <option value="AMD">AMD Inc. (AMD)</option>
                        <option value="CRM">Salesforce Inc. (CRM)</option>
                        <option value="SPY">SPDR S&P 500 ETF (SPY)</option>
                        <option value="QQQ">Invesco QQQ Trust (QQQ)</option>
                        <option value="IWM">Russell 2000 ETF (IWM)</option>
                        <option value="DIA">Dow Jones ETF (DIA)</option>
                        <option value="ARKK">ARK Innovation ETF (ARKK)</option>
                        <option value="TQQQ">ProShares UltraPro QQQ (TQQQ)</option>
                        <option value="SQQQ">ProShares UltraPro Short QQQ (SQQQ)</option>
                        <option value="UPRO">ProShares UltraPro S&P500 (UPRO)</option>
                        <option value="PLTR">Palantir Technologies (PLTR)</option>
                        <option value="COIN">Coinbase Global (COIN)</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="customTicker">Or Enter Custom Stock Symbol:</label>
                    <input type="text" id="customTicker" placeholder="e.g., PLTR, COIN, GME" style="text-transform: uppercase;">
                </div>

                <div class="form-group">
                    <label for="quantity">Quantity:</label>
                    <input type="number" id="quantity" min="1" max="10000" value="100" required>
                </div>

                <div class="button-grid">
                    <button class="btn btn-buy" onclick="executeTrade('buy')">Buy</button>
                    <button class="btn btn-sell" onclick="executeTrade('sell')">Sell</button>
                </div>

                <div class="button-row">
                    <button class="btn btn-cancel" onclick="cancelAllOrders()" style="font-size: 9px; padding: 6px 8px;">Cancel All</button>
                    <button class="btn btn-secondary" onclick="setStopLoss()" style="font-size: 9px; padding: 6px 8px;">Stop Loss</button>
                    <button class="btn btn-success" onclick="setProfitTarget()" style="font-size: 9px; padding: 6px 8px;">Profit</button>
                </div>

                <div class="button-row" style="margin-top: 8px;">
                    <button class="btn btn-primary" id="holdBtn" onclick="toggleHoldMode()" style="font-size: 9px; padding: 6px 8px;">HOLD</button>
                    <button class="btn btn-danger" onclick="closeAllPositions()">Close All</button>
                    <button class="btn btn-secondary" onclick="emergencyStop()" style="font-size: 8px; padding: 6px 8px;">Emergency STP</button>
                </div>

                <div class="automation-panel">
                    <div class="automation-status">
                        <span>Auto Trading:</span>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div class="status-indicator status-inactive" id="autoStatus"></div>
                            <span id="autoStatusText">Inactive</span>
                        </div>
                    </div>
                    <div class="automation-status" style="margin-top: 8px;">
                        <span>Position Mode:</span>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div class="status-indicator status-inactive" id="holdStatus"></div>
                            <span id="holdStatusText">Trading</span>
                        </div>
                    </div>
                    <button class="btn btn-primary" id="toggleAuto" onclick="toggleAutomation()" style="width: 100%; font-size: 9px; padding: 6px 8px;">
                        Start Auto Trading
                    </button>
                </div>

                <div class="pnl-display">
                    <div class="indicator-label">Today's P&L</div>
                    <div class="pnl-value" id="totalPnL">$0.00</div>
                    <div style="display: flex; justify-content: space-between; font-size: 12px; margin-top: 8px;">
                        <span>Realized: <span id="realizedPnL">$0.00</span></span>
                        <span>Unrealized: <span id="unrealizedPnL">$0.00</span></span>
                    </div>
                </div>

                <div class="trades-panel">
                    <div class="indicator-label" style="margin-bottom: 10px;">Active Trades</div>
                    <div id="activeTradesList">No active trades</div>
                </div>
            </div>

            <div class="center-panel">
                <div class="section-title">Market Analysis</div>

                <div class="chart-controls">
                    <button class="chart-btn active" data-timeframe="1m">1M</button>
                    <button class="chart-btn" data-timeframe="5m">5M</button>
                    <button class="chart-btn" data-timeframe="15m">15M</button>
                    <button class="chart-btn" data-timeframe="1h">1H</button>
                </div>

                <div class="chart-container" id="chartContainer">
                    <canvas id="priceChart" style="width: 100%; height: 100%;"></canvas>
                </div>

                <div class="indicators-grid">
                    <div class="indicator-card">
                        <div class="indicator-value" id="currentPrice">$0.00</div>
                        <div class="indicator-label">Price (1m)</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="rsi_1m">0.00</div>
                        <div class="indicator-label">RSI (1m)</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="rsi_5m">0.00</div>
                        <div class="indicator-label">RSI (5m)</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="rsi_15m">0.00</div>
                        <div class="indicator-label">RSI (15m)</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="macd_1m">0.00</div>
                        <div class="indicator-label">MACD (1m)</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="macd_15m">0.00</div>
                        <div class="indicator-label">MACD (15m)</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="sma20_4h">0.00</div>
                        <div class="indicator-label">SMA20 (4h)</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="volume">0</div>
                        <div class="indicator-label">Volume</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="customIndicatorValue">N/A</div>
                        <div class="indicator-label">Strategy Signal</div>
                    </div>
                </div>

                <div class="signal-display" id="signalDisplay">
                    <div id="signalText">HOLD</div>
                </div>
            </div>

            <div class="right-panel">
                <div class="section-title">Custom Strategy</div>

                <div class="form-group">
                    <label for="customScript">ThinkOrSwim Multi-Timeframe Strategy:</label>
                    <textarea id="customScript" class="custom-script-area" placeholder="# ThinkOrSwim Multi-Timeframe Strategy Code
# This bot supports 1m, 5m, 15m, and 4h timeframe analysis
# Use aggregationPeriod to reference different timeframes
#
# Example Multi-Timeframe Strategy:
# def rsi_1m = RSI(length = 14, aggregationPeriod = AggregationPeriod.MIN);
# def rsi_5m = RSI(length = 14, aggregationPeriod = AggregationPeriod.FIVE_MIN);
# def rsi_15m = RSI(length = 14, aggregationPeriod = AggregationPeriod.FIFTEEN_MIN);
# def rsi_4h = RSI(length = 14, aggregationPeriod = AggregationPeriod.FOUR_HOURS);
#
# def macd_15m = MACD(aggregationPeriod = AggregationPeriod.FIFTEEN_MIN);
# def sma20_4h = Average(close, 20, aggregationPeriod = AggregationPeriod.FOUR_HOURS);
#
# # Multi-timeframe conditions
# def trend_bullish_4h = close > sma20_4h;
# def momentum_15m = macd_15m.Value > macd_15m.Avg;
# def oversold_5m = rsi_5m < 30;
# def entry_1m = rsi_1m < 25;
#
# # Combined entry signal
# BUY_CONDITION = trend_bullish_4h and momentum_15m and oversold_5m and entry_1m;
# SELL_CONDITION = rsi_1m > 75 or rsi_5m > 80;"></textarea>
                </div>

                <div class="button-row">
                    <button class="btn btn-primary" onclick="loadStrategy()" style="font-size: 9px; padding: 6px 8px;">Load</button>
                    <button class="btn btn-secondary" onclick="testStrategy()" style="font-size: 9px; padding: 6px 8px;">Test</button>
                    <button class="btn btn-danger" onclick="clearStrategy()" style="font-size: 9px; padding: 6px 8px;">Clear</button>
                </div>

                <div class="form-group" style="margin-top: 15px;">
                    <label for="stopLossPercent">Stop Loss %:</label>
                    <input type="number" id="stopLossPercent" min="0.1" max="10" step="0.1" value="2">

                    <label for="profitTargetPercent">Profit Target %:</label>
                    <input type="number" id="profitTargetPercent" min="0.1" max="20" step="0.1" value="4">
                </div>

                <button class="btn btn-primary" onclick="showLogs()" style="width: 100%; margin-top: 12px; font-size: 9px; padding: 6px 8px;">
                    View Logs
                </button>

                <div class="logs-panel" id="logsPanel">
                    <div id="logEntries"></div>
                </div>
            </div>

            <div class="watchlist-panel">
                <div class="section-title">Live Watchlist</div>

                <div class="watchlist-controls">
                    <button class="watchlist-btn" onclick="refreshWatchlist()">Refresh</button>
                    <button class="watchlist-btn" onclick="editWatchlist()">Edit</button>
                </div>

                <div class="watchlist-container" id="watchlistContainer">
                    <div class="watchlist-item">
                        <div class="watchlist-ticker">Loading...</div>
                        <div class="watchlist-price">$0.00</div>
                    </div>
                </div>
            </div>

            <div class="scanner-panel">
                <div class="section-title">Market Scanner</div>

                <div class="scanner-controls">
                    <textarea id="scannerCode" class="scanner-code-area" placeholder="# Enter your ThinkOrSwim scanning code:
# Example 1 - RSI Oversold:
# def rsi = RSI(length = 14);
# def volume_avg = Average(volume, 20);
# rsi < 30 and volume > volume_avg * 1.5;"></textarea>

                    <div style="display: flex; gap: 4px;">
                        <button class="scanner-btn" id="scanBtn" onclick="startScanning()" style="flex: 1; font-size: 8px; padding: 4px 6px;">Start Scan</button>
                        <button class="scanner-btn" onclick="stopScanning()" style="flex: 1; font-size: 8px; padding: 4px 6px;">Stop</button>
                    </div>
                </div>

                <div class="scan-status" id="scanStatus">
                    Ready to scan. Enter criteria above.
                </div>

                <div class="scanner-container" id="scannerContainer">
                    <div class="scanner-item">
                        <div class="scanner-ticker">No scans yet</div>
                        <div style="font-size: 12px; opacity: 0.8;">Enter criteria and click Start Scan</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        var API_BASE_URL = window.location.origin;
        var currentTicker = '';
        var isConnected = false;
        var isAutoTrading = false;
        var isHoldMode = false;
        var emergencyStopActive = false;
        var currentTimeframe = '1m';
        var customStrategy = '';
        var priceData = {};
        var multiTimeframeData = {};
        var indicators = {};
        var activeTrades = [];
        var totalPnL = 0;
        var realizedPnL = 0;
        var unrealizedPnL = 0;
        var autoTradingInterval = null;

        var watchlistStocks = ['AAPL', 'TSLA', 'GOOGL', 'MSFT', 'NVDA', 'META', 'AMZN', 'SPY', 'QQQ', 'AMD'];
        var watchlistData = {};

        var isScanning = false;
        var scanningInterval = null;
        var scannerCode = '';
        var scannedStocks = [];
        var allStocks = [
            'AAPL', 'TSLA', 'GOOGL', 'MSFT', 'NVDA', 'META', 'AMZN', 'NFLX', 'AMD', 'CRM',
            'SPY', 'QQQ', 'IWM', 'DIA', 'ARKK', 'TQQQ', 'SQQQ', 'VTI', 'VOO', 'VEA',
            'PLTR', 'COIN', 'RBLX', 'HOOD', 'SOFI', 'GME', 'AMC', 'BB', 'NOK', 'SNDL',
            'F', 'GE', 'BAC', 'JPM', 'WFC', 'V', 'MA', 'KO', 'PEP', 'DIS', 'NKE',
            'BABA', 'TSM', 'ASML', 'INTC', 'CSCO', 'ORCL', 'ADBE', 'PYPL', 'AVGO', 'TXN'
        ];
        var scannerResults = {};

        var POPULAR_STOCKS = [
            'AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA', 'META', 'NVDA', 'NFLX', 'AMD', 'CRM',
            'SPY', 'QQQ', 'IWM', 'DIA', 'ARKK', 'TQQQ', 'SQQQ', 'SPXL', 'UPRO', 'TMF'
        ];

        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
        });

        function initializeApp() {
            loadStockList();
            setupEventListeners();
            checkAPIConnection();
            startRealTimeUpdates();
            initializeWatchlist();
            addLog('System initialized', 'success');
        }

        function loadStockList() {
            var tickerSelect = document.getElementById('ticker');
            tickerSelect.innerHTML = '<option value="">Choose a stock...</option>';

            for (var i = 0; i < POPULAR_STOCKS.length; i++) {
                var option = document.createElement('option');
                option.value = POPULAR_STOCKS[i];
                option.textContent = POPULAR_STOCKS[i];
                option.style.backgroundColor = '#2d3748';
                option.style.color = 'white';
                tickerSelect.appendChild(option);
            }

            addLog('Stock list loaded with ' + POPULAR_STOCKS.length + ' symbols', 'info');
        }

        function setupEventListeners() {
            document.getElementById('ticker').addEventListener('change', function() {
                if (this.value) {
                    document.getElementById('customTicker').value = '';
                    currentTicker = this.value;
                    addLog('Selected ticker: ' + currentTicker, 'info');
                    updateMarketData(currentTicker);
                }
            });

            document.getElementById('customTicker').addEventListener('input', function() {
                var customValue = this.value.toUpperCase().trim();
                if (customValue) {
                    document.getElementById('ticker').value = '';
                    currentTicker = customValue;
                    addLog('Custom ticker entered: ' + currentTicker, 'info');

                    if (customValue.length >= 1) {
                        updateMarketData(currentTicker);
                    }
                }
            });

            var chartBtns = document.querySelectorAll('.chart-btn');
            for (var i = 0; i < chartBtns.length; i++) {
                chartBtns[i].addEventListener('click', function() {
                    var allBtns = document.querySelectorAll('.chart-btn');
                    for (var j = 0; j < allBtns.length; j++) {
                        allBtns[j].classList.remove('active');
                    }
                    this.classList.add('active');
                    currentTimeframe = this.dataset.timeframe;
                    addLog('Changed timeframe to: ' + currentTimeframe, 'info');
                });
            }
        }

        function checkAPIConnection() {
            fetch(API_BASE_URL + '/api/health')
                .then(function(response) {
                    if (response.ok) {
                        isConnected = true;
                        updateConnectionStatus('Online');
                        addLog('API connected', 'success');
                    } else {
                        throw new Error('API check failed');
                    }
                })
                .catch(function(error) {
                    isConnected = false;
                    updateConnectionStatus('Offline');
                    addLog('API connection failed', 'error');
                });
        }

        function updateConnectionStatus(status) {
            var statusElement = document.getElementById('connectionStatus');
            if (status === 'Online') {
                statusElement.textContent = 'Online';
                statusElement.className = 'connection-status connection-online';
            } else {
                statusElement.textContent = 'Offline';
                statusElement.className = 'connection-status connection-offline';
            }
        }

        function startRealTimeUpdates() {
            setInterval(function() {
                if (currentTicker && isConnected) {
                    updateMarketData(currentTicker);
                }
            }, 5000);

            setInterval(function() {
                if (activeTrades.length > 0) {
                    updatePnLDisplay();
                }
            }, 10000);

            setInterval(function() {
                if (isAutoTrading && currentTicker && customStrategy) {
                    checkTradingSignals();
                }
            }, 30000);

            setInterval(function() {
                if (isConnected) {
                    updateWatchlist();
                }
            }, 3000);

            setInterval(function() {
                if (isScanning && isConnected) {
                    runMarketScan();
                }
            }, 10000);
        }

        function updateMarketData(symbol) {
            if (!isConnected) return;

            # Fetch data for all required timeframes
            var timeframes = ['1m', '5m', '15m', '4h'];
            var dataPromises = [];

            for (var i = 0; i < timeframes.length; i++) {
                var tf = timeframes[i];
                dataPromises.push(
                    fetch(API_BASE_URL + '/api/market-data/' + symbol + '?timeframe=' + tf)
                        .then(function(response) { return response.json(); })
                        .catch(function(error) {
                            # Fallback to simulated multi-timeframe data
                            return generateSimulatedTimeframeData(symbol, tf);
                        })
                );
            }

            Promise.all(dataPromises)
                .then(function(results) {
                    # Organize data by timeframe
                    multiTimeframeData = {};
                    for (var i = 0; i < timeframes.length; i++) {
                        multiTimeframeData[timeframes[i]] = results[i];
                    }

                    # Use 1m data as primary for display
                    var primaryData = multiTimeframeData['1m'];
                    if (primaryData && primaryData.currentPrice) {
                        updateMultiTimeframeIndicators(primaryData);

                        # Store price data for charting
                        if (!priceData[symbol]) priceData[symbol] = [];
                        priceData[symbol].push({
                            time: new Date(),
                            price: primaryData.currentPrice,
                            volume: primaryData.volume
                        });

                        # Keep only last 100 data points per symbol
                        if (priceData[symbol].length > 100) {
                            priceData[symbol] = priceData[symbol].slice(-100);
                        }

                        updateChart();
                    }
                })
                .catch(function(error) {
                    addLog('Multi-timeframe data error: ' + error.message, 'error');
                });
        }

        function generateSimulatedTimeframeData(symbol, timeframe) {
            # Generate simulated multi-timeframe data
            var basePrice = 150 + Math.random() * 50;
            var volatility = timeframe === '1m' ? 1 : timeframe === '5m' ? 2 : timeframe === '15m' ? 3 : 5;

            return {
                symbol: symbol,
                timeframe: timeframe,
                currentPrice: basePrice + (Math.random() - 0.5) * volatility,
                rsi: 30 + Math.random() * 40,
                macd: {
                    macd: (Math.random() - 0.5) * 2,
                    signal: (Math.random() - 0.5) * 1.5,
                    histogram: (Math.random() - 0.5) * 0.5
                },
                sma20: basePrice * (0.98 + Math.random() * 0.04),
                volume: Math.floor(Math.random() * 1000000),
                high: basePrice + Math.random() * 2,
                low: basePrice - Math.random() * 2,
                open: basePrice + (Math.random() - 0.5) * 1
            };
        }

        function updateMultiTimeframeIndicators(primaryData) {
            indicators = primaryData;

            # Update primary price display
            document.getElementById('currentPrice').textContent = '

        function updateChart() {
            var currentSymbolData = priceData[currentTicker];
            if (!currentSymbolData || currentSymbolData.length === 0) return;

            var canvas = document.getElementById('priceChart');
            var ctx = canvas.getContext('2d');

            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (currentSymbolData.length < 2) return;

            var prices = currentSymbolData.map(function(d) { return d.price; });
            var minPrice = Math.min.apply(Math, prices);
            var maxPrice = Math.max.apply(Math, prices);
            var priceRange = maxPrice - minPrice || 1;

            ctx.strokeStyle = '#4facfe';
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (var i = 0; i < currentSymbolData.length; i++) {
                var x = (i / (currentSymbolData.length - 1)) * canvas.width;
                var y = canvas.height - ((currentSymbolData[i].price - minPrice) / priceRange) * canvas.height;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.stroke();

            # Add timeframe indicator
            ctx.fillStyle = '#4facfe';
            ctx.font = '12px Arial';
            ctx.fillText('Timeframe: ' + currentTimeframe, 10, 20);
        }

        function executeTrade(action) {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!isConnected) {
                alert('API connection lost');
                return;
            }

            # Check trading permissions (HOLD mode, emergency stop)
            if (!checkTradingPermissions()) {
                alert('Trading is currently blocked. Check your trading mode status.');
                return;
            }

            var quantity = parseInt(document.getElementById('quantity').value);
            var currentPrice = indicators.currentPrice || 100;

            var orderData = {
                symbol: currentTicker,
                action: action.toUpperCase(),
                quantity: quantity,
                orderType: 'MARKET',
                timeInForce: 'DAY',
                price: currentPrice
            };

            fetch(API_BASE_URL + '/api/orders', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(orderData)
            })
            .then(function(response) {
                return response.json();
            })
            .then(function(result) {
                if (result.success) {
                    addLog(action.toUpperCase() + ' order executed: ' + quantity + ' shares at

        function cancelAllOrders() {
            addLog('All orders cancelled', 'warning');
            alert('All orders cancelled');
        }

        function setStopLoss() {
            var stopLossPercent = document.getElementById('stopLossPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var stopPrice = currentPrice * (1 - stopLossPercent / 100);

            addLog('Stop loss set at $' + stopPrice.toFixed(2), 'warning');
            alert('Stop loss set at $' + stopPrice.toFixed(2));
        }

        function setProfitTarget() {
            var profitTargetPercent = document.getElementById('profitTargetPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var targetPrice = currentPrice * (1 + profitTargetPercent / 100);

            addLog('Profit target set at $' + targetPrice.toFixed(2), 'success');
            alert('Profit target set at $' + targetPrice.toFixed(2));
        }

        function toggleAutomation() {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            isAutoTrading = !isAutoTrading;
            var toggleBtn = document.getElementById('toggleAuto');
            var statusIndicator = document.getElementById('autoStatus');
            var statusText = document.getElementById('autoStatusText');

            if (isAutoTrading) {
                toggleBtn.textContent = 'Stop Auto Trading';
                toggleBtn.className = 'btn btn-danger';
                statusIndicator.className = 'status-indicator status-active';
                statusText.textContent = 'Active';
                addLog('Auto trading started', 'success');

                autoTradingInterval = setInterval(function() {
                    checkTradingSignals();
                }, 30000);

            } else {
                toggleBtn.textContent = 'Start Auto Trading';
                toggleBtn.className = 'btn btn-primary';
                statusIndicator.className = 'status-indicator status-inactive';
                statusText.textContent = 'Inactive';
                addLog('Auto trading stopped', 'warning');

                if (autoTradingInterval) {
                    clearInterval(autoTradingInterval);
                    autoTradingInterval = null;
                }
            }
        }

        function loadStrategy() {
            var strategyCode = document.getElementById('customScript').value.trim();
            if (!strategyCode) {
                alert('Please enter a strategy first');
                return;
            }

            customStrategy = strategyCode;
            addLog('Strategy loaded', 'success');
            alert('Strategy loaded successfully!');
        }

        function testStrategy() {
            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            if (!indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            try {
                var result = evaluateCustomStrategy(indicators);
                addLog('Strategy test result: ' + result, 'info');
                alert('Strategy test result: ' + result);
            } catch (error) {
                addLog('Strategy test failed', 'error');
                alert('Strategy test failed');
            }
        }

        function clearStrategy() {
            customStrategy = '';
            document.getElementById('customScript').value = '';
            addLog('Strategy cleared', 'info');
        }

        function evaluateMultiTimeframeStrategy(timeframeData, strategy) {
            if (!strategy) return 'N/A';

            try {
                # Extract data from all timeframes
                var data_1m = timeframeData['1m'] || {};
                var data_5m = timeframeData['5m'] || {};
                var data_15m = timeframeData['15m'] || {};
                var data_4h = timeframeData['4h'] || {};

                # Convert ThinkOrSwim multi-timeframe syntax to JavaScript
                var jsCode = strategy
                    # Handle aggregationPeriod references
                    .replace(/RSI\(length\s*=\s*(\d+),\s*aggregationPeriod\s*=\s*AggregationPeriod\.MIN\)/g, function(match, length) {
                        return data_1m.rsi || 50;
                    })
                    .replace(/RSI\(length\s*=\s*(\d+),\s*aggregationPeriod\s*=\s*AggregationPeriod\.FIVE_MIN\)/g, function(match, length) {
                        return data_5m.rsi || 50;
                    })
                    .replace(/RSI\(length\s*=\s*(\d+),\s*aggregationPeriod\s*=\s*AggregationPeriod\.FIFTEEN_MIN\)/g, function(match, length) {
                        return data_15m.rsi || 50;
                    })
                    .replace(/RSI\(length\s*=\s*(\d+),\s*aggregationPeriod\s*=\s*AggregationPeriod\.FOUR_HOURS\)/g, function(match, length) {
                        return data_4h.rsi || 50;
                    })

                    # Handle MACD with timeframes
                    .replace(/MACD\(aggregationPeriod\s*=\s*AggregationPeriod\.MIN\)/g, function() {
                        var macd = data_1m.macd || {macd: 0, signal: 0};
                        return '{Value: ' + macd.macd + ', Avg: ' + macd.signal + '}';
                    })
                    .replace(/MACD\(aggregationPeriod\s*=\s*AggregationPeriod\.FIFTEEN_MIN\)/g, function() {
                        var macd = data_15m.macd || {macd: 0, signal: 0};
                        return '{Value: ' + macd.macd + ', Avg: ' + macd.signal + '}';
                    })

                    # Handle Average (SMA) with timeframes
                    .replace(/Average\(close,\s*(\d+),\s*aggregationPeriod\s*=\s*AggregationPeriod\.FOUR_HOURS\)/g, function(match, period) {
                        return data_4h.sma20 || data_4h.currentPrice || 100;
                    })

                    # Handle def statements
                    .replace(/def\s+(\w+)\s*=/g, 'var $1 =')

                    # Handle basic price references
                    .replace(/\bclose\b/g, data_1m.currentPrice || 100)
                    .replace(/\bhigh\b/g, data_1m.high || data_1m.currentPrice || 100)
                    .replace(/\blow\b/g, data_1m.low || data_1m.currentPrice || 100)
                    .replace(/\bvolume\b/g, data_1m.volume || 0)

                    # Handle logical operators
                    .replace(/\band\b/g, '&&')
                    .replace(/\bor\b/g, '||')
                    .replace(/\bnot\b/g, '!')

                    # Remove comments (only # comments as per your note)
                    .replace(/#.*$/gm, '')
                    .replace(/\s+/g, ' ')
                    .trim();

                # Look for BUY_CONDITION and SELL_CONDITION
                var lines = jsCode.split(';');
                var buyCondition = false;
                var sellCondition = false;

                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i].trim();
                    if (line.indexOf('BUY_CONDITION') !== -1) {
                        # Extract and evaluate buy condition
                        var condition = line.split('=')[1];
                        if (condition) {
                            try {
                                buyCondition = eval(condition.trim());
                            } catch (e) {
                                buyCondition = evaluateConditionPatterns(condition, timeframeData);
                            }
                        }
                    }
                    if (line.indexOf('SELL_CONDITION') !== -1) {
                        # Extract and evaluate sell condition
                        var condition = line.split('=')[1];
                        if (condition) {
                            try {
                                sellCondition = eval(condition.trim());
                            } catch (e) {
                                sellCondition = evaluateConditionPatterns(condition, timeframeData);
                            }
                        }
                    }
                }

                # Return signal based on conditions
                if (buyCondition) return 'BUY';
                if (sellCondition) return 'SELL';
                return 'HOLD';

            } catch (error) {
                console.log('Multi-timeframe strategy evaluation error:', error);
                return 'ERROR';
            }
        }

        function evaluateConditionPatterns(condition, timeframeData) {
            # Pattern matching for complex multi-timeframe conditions
            var data_1m = timeframeData['1m'] || {};
            var data_5m = timeframeData['5m'] || {};
            var data_15m = timeframeData['15m'] || {};
            var data_4h = timeframeData['4h'] || {};

            # Check for trend alignment
            if (condition.indexOf('trend_bullish') !== -1) {
                var currentPrice = data_1m.currentPrice || 100;
                var sma20_4h = data_4h.sma20 || currentPrice;
                return currentPrice > sma20_4h;
            }

            # Check for momentum conditions
            if (condition.indexOf('momentum') !== -1) {
                var macd_15m = data_15m.macd || {macd: 0, signal: 0};
                return macd_15m.macd > macd_15m.signal;
            }

            # Check for oversold conditions
            if (condition.indexOf('oversold') !== -1) {
                return (data_5m.rsi || 50) < 30;
            }

            # Check for entry conditions
            if (condition.indexOf('entry') !== -1) {
                return (data_1m.rsi || 50) < 25;
            }

            return false;
        }

        function checkTradingSignals() {
            if (!isAutoTrading || !currentTicker || !customStrategy) return;

            # Check if trading is blocked by HOLD mode or emergency stop
            if (!checkTradingPermissions()) {
                return;
            }

            try {
                # Use multi-timeframe evaluation
                var signal = evaluateMultiTimeframeStrategy(multiTimeframeData, customStrategy);

                if (signal === 'BUY' || signal === 'SELL') {
                    addLog('Multi-timeframe auto signal: ' + signal + ' for ' + currentTicker, 'info');

                    var hasPosition = false;
                    for (var i = 0; i < activeTrades.length; i++) {
                        if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                            hasPosition = true;
                            break;
                        }
                    }

                    if (signal === 'BUY' && !hasPosition) {
                        addLog('Multi-timeframe BUY signal confirmed across timeframes', 'success');
                        executeTrade('buy');
                    } else if (signal === 'SELL' && hasPosition) {
                        addLog('Multi-timeframe SELL signal confirmed across timeframes', 'warning');
                        executeTrade('sell');
                    }
                }
            } catch (error) {
                addLog('Multi-timeframe signal check failed: ' + error.message, 'error');
            }
        }
                     + primaryData.currentPrice.toFixed(2);
            document.getElementById('volume').textContent = (primaryData.volume || 0).toLocaleString();

            # Update multi-timeframe RSI indicators
            if (multiTimeframeData['1m']) {
                document.getElementById('rsi_1m').textContent = (multiTimeframeData['1m'].rsi || 0).toFixed(2);
            }
            if (multiTimeframeData['5m']) {
                document.getElementById('rsi_5m').textContent = (multiTimeframeData['5m'].rsi || 0).toFixed(2);
            }
            if (multiTimeframeData['15m']) {
                document.getElementById('rsi_15m').textContent = (multiTimeframeData['15m'].rsi || 0).toFixed(2);
            }

            # Update multi-timeframe MACD indicators
            if (multiTimeframeData['1m'] && multiTimeframeData['1m'].macd) {
                document.getElementById('macd_1m').textContent = multiTimeframeData['1m'].macd.macd.toFixed(4);
            }
            if (multiTimeframeData['15m'] && multiTimeframeData['15m'].macd) {
                document.getElementById('macd_15m').textContent = multiTimeframeData['15m'].macd.macd.toFixed(4);
            }

            # Update 4-hour SMA
            if (multiTimeframeData['4h']) {
                document.getElementById('sma20_4h').textContent = '

        function updateChart() {
            if (priceData.length === 0) return;

            var canvas = document.getElementById('priceChart');
            var ctx = canvas.getContext('2d');

            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (priceData.length < 2) return;

            var prices = priceData.map(function(d) { return d.price; });
            var minPrice = Math.min.apply(Math, prices);
            var maxPrice = Math.max.apply(Math, prices);
            var priceRange = maxPrice - minPrice || 1;

            ctx.strokeStyle = '#4facfe';
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (var i = 0; i < priceData.length; i++) {
                var x = (i / (priceData.length - 1)) * canvas.width;
                var y = canvas.height - ((priceData[i].price - minPrice) / priceRange) * canvas.height;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.stroke();
        }

        function executeTrade(action) {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!isConnected) {
                alert('API connection lost');
                return;
            }

            var quantity = parseInt(document.getElementById('quantity').value);
            var currentPrice = indicators.currentPrice || 100;

            var orderData = {
                symbol: currentTicker,
                action: action.toUpperCase(),
                quantity: quantity,
                orderType: 'MARKET',
                timeInForce: 'DAY',
                price: currentPrice
            };

            fetch(API_BASE_URL + '/api/orders', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(orderData)
            })
            .then(function(response) {
                return response.json();
            })
            .then(function(result) {
                if (result.success) {
                    addLog(action.toUpperCase() + ' order executed: ' + quantity + ' shares at $' + currentPrice.toFixed(2), 'success');

                    var trade = {
                        id: Date.now(),
                        symbol: currentTicker,
                        action: action.toUpperCase(),
                        quantity: quantity,
                        entryPrice: currentPrice,
                        timestamp: new Date(),
                        status: 'OPEN'
                    };

                    if (action.toUpperCase() === 'BUY') {
                        activeTrades.push(trade);
                    } else {
                        var existingTrade = null;
                        for (var i = 0; i < activeTrades.length; i++) {
                            if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                                existingTrade = activeTrades[i];
                                break;
                            }
                        }

                        if (existingTrade) {
                            existingTrade.status = 'CLOSED';
                            existingTrade.exitPrice = currentPrice;
                            var profit = (currentPrice - existingTrade.entryPrice) * existingTrade.quantity;
                            realizedPnL += profit;
                            addLog('Position closed: ' + (profit > 0 ? '+' : '') + '$' + profit.toFixed(2), profit > 0 ? 'success' : 'error');
                        }
                    }

                    updateActiveTradesDisplay();
                    updatePnLDisplay();
                    alert(action.toUpperCase() + ' order submitted successfully!');
                } else {
                    throw new Error(result.error);
                }
            })
            .catch(function(error) {
                addLog('Trade failed: ' + error.message, 'error');
                alert('Trade failed: ' + error.message);
            });
        }

        function cancelAllOrders() {
            addLog('All orders cancelled', 'warning');
            alert('All orders cancelled');
        }

        function setStopLoss() {
            var stopLossPercent = document.getElementById('stopLossPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var stopPrice = currentPrice * (1 - stopLossPercent / 100);

            addLog('Stop loss set at $' + stopPrice.toFixed(2), 'warning');
            alert('Stop loss set at $' + stopPrice.toFixed(2));
        }

        function setProfitTarget() {
            var profitTargetPercent = document.getElementById('profitTargetPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var targetPrice = currentPrice * (1 + profitTargetPercent / 100);

            addLog('Profit target set at $' + targetPrice.toFixed(2), 'success');
            alert('Profit target set at $' + targetPrice.toFixed(2));
        }

        function toggleAutomation() {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            isAutoTrading = !isAutoTrading;
            var toggleBtn = document.getElementById('toggleAuto');
            var statusIndicator = document.getElementById('autoStatus');
            var statusText = document.getElementById('autoStatusText');

            if (isAutoTrading) {
                toggleBtn.textContent = 'Stop Auto Trading';
                toggleBtn.className = 'btn btn-danger';
                statusIndicator.className = 'status-indicator status-active';
                statusText.textContent = 'Active';
                addLog('Auto trading started', 'success');

                autoTradingInterval = setInterval(function() {
                    checkTradingSignals();
                }, 30000);

            } else {
                toggleBtn.textContent = 'Start Auto Trading';
                toggleBtn.className = 'btn btn-primary';
                statusIndicator.className = 'status-indicator status-inactive';
                statusText.textContent = 'Inactive';
                addLog('Auto trading stopped', 'warning');

                if (autoTradingInterval) {
                    clearInterval(autoTradingInterval);
                    autoTradingInterval = null;
                }
            }
        }

        function loadStrategy() {
            var strategyCode = document.getElementById('customScript').value.trim();
            if (!strategyCode) {
                alert('Please enter a strategy first');
                return;
            }

            customStrategy = strategyCode;
            addLog('Strategy loaded', 'success');
            alert('Strategy loaded successfully!');
        }

        function testStrategy() {
            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            if (!indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            try {
                var result = evaluateCustomStrategy(indicators);
                addLog('Strategy test result: ' + result, 'info');
                alert('Strategy test result: ' + result);
            } catch (error) {
                addLog('Strategy test failed', 'error');
                alert('Strategy test failed');
            }
        }

        function clearStrategy() {
            customStrategy = '';
            document.getElementById('customScript').value = '';
            addLog('Strategy cleared', 'info');
        }

        function evaluateCustomStrategy(data) {
            if (!customStrategy) return 'N/A';

            try {
                var rsi = data.rsi || 50;
                var macd = data.macd ? data.macd.macd : 0;
                var price = data.currentPrice || 100;

                if (customStrategy.indexOf('rsi < 30') !== -1 && rsi < 30) {
                    return 'BUY';
                }
                if (customStrategy.indexOf('rsi > 70') !== -1 && rsi > 70) {
                    return 'SELL';
                }

                return 'HOLD';
            } catch (error) {
                throw new Error('Strategy evaluation failed');
            }
        }

        function checkTradingSignals() {
            if (!isAutoTrading || !currentTicker || !customStrategy) return;

            try {
                var signal = evaluateCustomStrategy(indicators);

                if (signal === 'BUY' || signal === 'SELL') {
                    addLog('Auto signal: ' + signal, 'info');

                    var hasPosition = false;
                    for (var i = 0; i < activeTrades.length; i++) {
                        if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                            hasPosition = true;
                            break;
                        }
                    }
                     + (multiTimeframeData['4h'].sma20 || 0).toFixed(2);
            }

            # Update signal display
            var signal = primaryData.signal || 'HOLD';
            var signalDisplay = document.getElementById('signalDisplay');
            var signalText = document.getElementById('signalText');

            signalText.textContent = signal;
            signalDisplay.className = 'signal-display signal-' + signal.toLowerCase();

            # Evaluate custom multi-timeframe strategy
            if (customStrategy) {
                try {
                    var customResult = evaluateMultiTimeframeStrategy(multiTimeframeData, customStrategy);
                    document.getElementById('customIndicatorValue').textContent = customResult;
                } catch (error) {
                    document.getElementById('customIndicatorValue').textContent = 'Error';
                    addLog('Multi-timeframe strategy error: ' + error.message, 'error');
                }
            }
        }

        function updateChart() {
            if (priceData.length === 0) return;

            var canvas = document.getElementById('priceChart');
            var ctx = canvas.getContext('2d');

            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (priceData.length < 2) return;

            var prices = priceData.map(function(d) { return d.price; });
            var minPrice = Math.min.apply(Math, prices);
            var maxPrice = Math.max.apply(Math, prices);
            var priceRange = maxPrice - minPrice || 1;

            ctx.strokeStyle = '#4facfe';
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (var i = 0; i < priceData.length; i++) {
                var x = (i / (priceData.length - 1)) * canvas.width;
                var y = canvas.height - ((priceData[i].price - minPrice) / priceRange) * canvas.height;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.stroke();
        }

        function executeTrade(action) {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!isConnected) {
                alert('API connection lost');
                return;
            }

            var quantity = parseInt(document.getElementById('quantity').value);
            var currentPrice = indicators.currentPrice || 100;

            var orderData = {
                symbol: currentTicker,
                action: action.toUpperCase(),
                quantity: quantity,
                orderType: 'MARKET',
                timeInForce: 'DAY',
                price: currentPrice
            };

            fetch(API_BASE_URL + '/api/orders', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(orderData)
            })
            .then(function(response) {
                return response.json();
            })
            .then(function(result) {
                if (result.success) {
                    addLog(action.toUpperCase() + ' order executed: ' + quantity + ' shares at $' + currentPrice.toFixed(2), 'success');

                    var trade = {
                        id: Date.now(),
                        symbol: currentTicker,
                        action: action.toUpperCase(),
                        quantity: quantity,
                        entryPrice: currentPrice,
                        timestamp: new Date(),
                        status: 'OPEN'
                    };

                    if (action.toUpperCase() === 'BUY') {
                        activeTrades.push(trade);
                    } else {
                        var existingTrade = null;
                        for (var i = 0; i < activeTrades.length; i++) {
                            if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                                existingTrade = activeTrades[i];
                                break;
                            }
                        }

                        if (existingTrade) {
                            existingTrade.status = 'CLOSED';
                            existingTrade.exitPrice = currentPrice;
                            var profit = (currentPrice - existingTrade.entryPrice) * existingTrade.quantity;
                            realizedPnL += profit;
                            addLog('Position closed: ' + (profit > 0 ? '+' : '') + '$' + profit.toFixed(2), profit > 0 ? 'success' : 'error');
                        }
                    }

                    updateActiveTradesDisplay();
                    updatePnLDisplay();
                    alert(action.toUpperCase() + ' order submitted successfully!');
                } else {
                    throw new Error(result.error);
                }
            })
            .catch(function(error) {
                addLog('Trade failed: ' + error.message, 'error');
                alert('Trade failed: ' + error.message);
            });
        }

        function cancelAllOrders() {
            addLog('All orders cancelled', 'warning');
            alert('All orders cancelled');
        }

        function setStopLoss() {
            var stopLossPercent = document.getElementById('stopLossPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var stopPrice = currentPrice * (1 - stopLossPercent / 100);

            addLog('Stop loss set at $' + stopPrice.toFixed(2), 'warning');
            alert('Stop loss set at $' + stopPrice.toFixed(2));
        }

        function setProfitTarget() {
            var profitTargetPercent = document.getElementById('profitTargetPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var targetPrice = currentPrice * (1 + profitTargetPercent / 100);

            addLog('Profit target set at $' + targetPrice.toFixed(2), 'success');
            alert('Profit target set at $' + targetPrice.toFixed(2));
        }

        function toggleAutomation() {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            isAutoTrading = !isAutoTrading;
            var toggleBtn = document.getElementById('toggleAuto');
            var statusIndicator = document.getElementById('autoStatus');
            var statusText = document.getElementById('autoStatusText');

            if (isAutoTrading) {
                toggleBtn.textContent = 'Stop Auto Trading';
                toggleBtn.className = 'btn btn-danger';
                statusIndicator.className = 'status-indicator status-active';
                statusText.textContent = 'Active';
                addLog('Auto trading started', 'success');

                autoTradingInterval = setInterval(function() {
                    checkTradingSignals();
                }, 30000);

            } else {
                toggleBtn.textContent = 'Start Auto Trading';
                toggleBtn.className = 'btn btn-primary';
                statusIndicator.className = 'status-indicator status-inactive';
                statusText.textContent = 'Inactive';
                addLog('Auto trading stopped', 'warning');

                if (autoTradingInterval) {
                    clearInterval(autoTradingInterval);
                    autoTradingInterval = null;
                }
            }
        }

        function loadStrategy() {
            var strategyCode = document.getElementById('customScript').value.trim();
            if (!strategyCode) {
                alert('Please enter a strategy first');
                return;
            }

            customStrategy = strategyCode;
            addLog('Strategy loaded', 'success');
            alert('Strategy loaded successfully!');
        }

        function testStrategy() {
            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            if (!indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            try {
                var result = evaluateCustomStrategy(indicators);
                addLog('Strategy test result: ' + result, 'info');
                alert('Strategy test result: ' + result);
            } catch (error) {
                addLog('Strategy test failed', 'error');
                alert('Strategy test failed');
            }
        }

        function clearStrategy() {
            customStrategy = '';
            document.getElementById('customScript').value = '';
            addLog('Strategy cleared', 'info');
        }

        function evaluateCustomStrategy(data) {
            if (!customStrategy) return 'N/A';

            try {
                var rsi = data.rsi || 50;
                var macd = data.macd ? data.macd.macd : 0;
                var price = data.currentPrice || 100;

                if (customStrategy.indexOf('rsi < 30') !== -1 && rsi < 30) {
                    return 'BUY';
                }
                if (customStrategy.indexOf('rsi > 70') !== -1 && rsi > 70) {
                    return 'SELL';
                }

                return 'HOLD';
            } catch (error) {
                throw new Error('Strategy evaluation failed');
            }
        }

        function checkTradingSignals() {
            if (!isAutoTrading || !currentTicker || !customStrategy) return;

            try {
                var signal = evaluateCustomStrategy(indicators);

                if (signal === 'BUY' || signal === 'SELL') {
                    addLog('Auto signal: ' + signal, 'info');

                    var hasPosition = false;
                    for (var i = 0; i < activeTrades.length; i++) {
                        if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                            hasPosition = true;
                            break;
                        }
                    }
                     + realizedPnL.toFixed(2), 'info');
        }

        function executeSellOrder(symbol, quantity) {
            # Execute the actual sell order
            var orderData = {
                symbol: symbol,
                action: 'SELL',
                quantity: quantity,
                orderType: 'MARKET',
                timeInForce: 'DAY'
            };

            fetch(API_BASE_URL + '/api/orders', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(orderData)
            })
            .then(function(response) {
                return response.json();
            })
            .then(function(result) {
                addLog('Emergency sell executed: ' + symbol, 'success');
            })
            .catch(function(error) {
                addLog('Emergency sell failed for ' + symbol + ': ' + error.message, 'error');
            });
        }

        function emergencyStop() {
            emergencyStopActive = !emergencyStopActive;
            var emergencyBtn = event.target;

            if (emergencyStopActive) {
                # FULL EMERGENCY STOP
                emergencyBtn.textContent = 'Resume';
                emergencyBtn.className = 'btn btn-danger';

                # Stop auto trading
                if (isAutoTrading) {
                    toggleAutomation();
                }

                # Activate hold mode
                if (!isHoldMode) {
                    toggleHoldMode();
                }

                # Close all positions
                closeAllPositions();

                # Cancel all pending orders
                cancelAllOrders();

                # Update status indicators
                var holdStatus = document.getElementById('holdStatus');
                holdStatus.className = 'status-indicator status-emergency';

                addLog('EMERGENCY STOP ACTIVATED - All trading halted, positions closed', 'error');
                alert('EMERGENCY STOP ACTIVATED!\\n\\n Auto trading stopped\\n All positions closed\\n All orders cancelled\\n System in HOLD mode');

            } else {
                # RESUME FROM EMERGENCY
                emergencyBtn.textContent = 'Emergency';
                emergencyBtn.className = 'btn btn-secondary';

                # Deactivate hold mode
                if (isHoldMode) {
                    toggleHoldMode();
                }

                addLog('Emergency stop deactivated - System ready for trading', 'success');
                alert('Emergency stop deactivated.\\nSystem is ready for trading.\\nYou can now restart auto trading if desired.');
            }
        }

        function checkTradingPermissions() {
            # Check if trading is allowed based on current modes
            if (emergencyStopActive) {
                addLog('Trade blocked: Emergency stop is active', 'error');
                return false;
            }

            if (isHoldMode) {
                addLog('Trade blocked: HOLD mode is active', 'warning');
                return false;
            }

            return true;
        }
        @media (max-width: 1200px) {
            .main-grid { grid-template-columns: 1fr; }
            .watchlist-panel {
                order: 3;
                max-height: 180px;
            }
            .scanner-panel {
                order: 4;
                max-height: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Fynda Auto Trading BOT</h1>
            <div class="connection-status" id="connectionStatus">Connecting...</div>
        </div>

        <div class="main-grid">
            <div class="left-panel">
                <div class="section-title">Trading Controls</div>

                <div class="form-group">
                    <label for="ticker">Select Stock:</label>
                    <select id="ticker" required>
                        <option value="">Loading stocks...</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="customTicker">Or Enter Custom Stock Symbol:</label>
                    <input type="text" id="customTicker" placeholder="e.g., PLTR, COIN, GME" style="text-transform: uppercase;">
                </div>

                <div class="form-group">
                    <label for="quantity">Quantity:</label>
                    <input type="number" id="quantity" min="1" max="10000" value="100" required>
                </div>

                <div class="button-grid">
                    <button class="btn btn-buy" onclick="executeTrade('buy')">Buy</button>
                    <button class="btn btn-sell" onclick="executeTrade('sell')">Sell</button>
                </div>

                <div class="button-row">
                    <button class="btn btn-cancel" onclick="cancelAllOrders()">Cancel All</button>
                    <button class="btn btn-secondary" onclick="setStopLoss()">Stop Loss</button>
                    <button class="btn btn-success" onclick="setProfitTarget()">Profit Target</button>
                </div>

                <div class="button-row" style="margin-top: 10px;">
                    <button class="btn btn-primary" id="holdBtn" onclick="toggleHoldMode()">Force HOLD</button>
                    <button class="btn btn-danger" onclick="closeAllPositions()">Close All</button>
                    <button class="btn btn-secondary" onclick="emergencyStop()">Emergency Stop</button>
                </div>

                <div class="automation-panel">
                    <div class="automation-status">
                        <span>Auto Trading:</span>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div class="status-indicator status-inactive" id="autoStatus"></div>
                            <span id="autoStatusText">Inactive</span>
                        </div>
                    </div>
                    <div class="automation-status" style="margin-top: 8px;">
                        <span>Position Mode:</span>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div class="status-indicator status-inactive" id="holdStatus"></div>
                            <span id="holdStatusText">Trading</span>
                        </div>
                    </div>
                    <button class="btn btn-primary" id="toggleAuto" onclick="toggleAutomation()" style="width: 100%;">
                        Start Auto Trading
                    </button>
                </div>

                <div class="pnl-display">
                    <div class="indicator-label">Today's P&L</div>
                    <div class="pnl-value" id="totalPnL">$0.00</div>
                    <div style="display: flex; justify-content: space-between; font-size: 12px; margin-top: 8px;">
                        <span>Realized: <span id="realizedPnL">$0.00</span></span>
                        <span>Unrealized: <span id="unrealizedPnL">$0.00</span></span>
                    </div>
                </div>

                <div class="trades-panel">
                    <div class="indicator-label" style="margin-bottom: 10px;">Active Trades</div>
                    <div id="activeTradesList">No active trades</div>
                </div>
            </div>

            <div class="center-panel">
                <div class="section-title">Market Analysis</div>

                <div class="chart-controls">
                    <button class="chart-btn active" data-timeframe="1m">1M</button>
                    <button class="chart-btn" data-timeframe="5m">5M</button>
                    <button class="chart-btn" data-timeframe="15m">15M</button>
                    <button class="chart-btn" data-timeframe="1h">1H</button>
                </div>

                <div class="chart-container" id="chartContainer">
                    <canvas id="priceChart" style="width: 100%; height: 100%;"></canvas>
                </div>

                <div class="indicators-grid">
                    <div class="indicator-card">
                        <div class="indicator-value" id="currentPrice">$0.00</div>
                        <div class="indicator-label">Price (1m)</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="rsi_1m">0.00</div>
                        <div class="indicator-label">RSI (1m)</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="rsi_5m">0.00</div>
                        <div class="indicator-label">RSI (5m)</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="rsi_15m">0.00</div>
                        <div class="indicator-label">RSI (15m)</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="macd_1m">0.00</div>
                        <div class="indicator-label">MACD (1m)</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="macd_15m">0.00</div>
                        <div class="indicator-label">MACD (15m)</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="sma20_4h">0.00</div>
                        <div class="indicator-label">SMA20 (4h)</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="volume">0</div>
                        <div class="indicator-label">Volume</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="customIndicatorValue">N/A</div>
                        <div class="indicator-label">Strategy Signal</div>
                    </div>
                </div>

                <div class="signal-display" id="signalDisplay">
                    <div id="signalText">HOLD</div>
                </div>
            </div>

            <div class="right-panel">
                <div class="section-title">Custom Strategy</div>

                <div class="form-group">
                    <label for="customScript">ThinkOrSwim Multi-Timeframe Strategy:</label>
                    <textarea id="customScript" class="custom-script-area" placeholder="# ThinkOrSwim Multi-Timeframe Strategy Code
# This bot supports 1m, 5m, 15m, and 4h timeframe analysis
# Use aggregationPeriod to reference different timeframes
#
# Example Multi-Timeframe Strategy:
# def rsi_1m = RSI(length = 14, aggregationPeriod = AggregationPeriod.MIN);
# def rsi_5m = RSI(length = 14, aggregationPeriod = AggregationPeriod.FIVE_MIN);
# def rsi_15m = RSI(length = 14, aggregationPeriod = AggregationPeriod.FIFTEEN_MIN);
# def rsi_4h = RSI(length = 14, aggregationPeriod = AggregationPeriod.FOUR_HOURS);
#
# def macd_15m = MACD(aggregationPeriod = AggregationPeriod.FIFTEEN_MIN);
# def sma20_4h = Average(close, 20, aggregationPeriod = AggregationPeriod.FOUR_HOURS);
#
# # Multi-timeframe conditions
# def trend_bullish_4h = close > sma20_4h;
# def momentum_15m = macd_15m.Value > macd_15m.Avg;
# def oversold_5m = rsi_5m < 30;
# def entry_1m = rsi_1m < 25;
#
# # Combined entry signal
# BUY_CONDITION = trend_bullish_4h and momentum_15m and oversold_5m and entry_1m;
# SELL_CONDITION = rsi_1m > 75 or rsi_5m > 80;"></textarea>
                </div>

                <div class="button-row">
                    <button class="btn btn-primary" onclick="loadStrategy()">Load</button>
                    <button class="btn btn-secondary" onclick="testStrategy()">Test</button>
                    <button class="btn btn-danger" onclick="clearStrategy()">Clear</button>
                </div>

                <div class="form-group" style="margin-top: 15px;">
                    <label for="stopLossPercent">Stop Loss %:</label>
                    <input type="number" id="stopLossPercent" min="0.1" max="10" step="0.1" value="2">

                    <label for="profitTargetPercent">Profit Target %:</label>
                    <input type="number" id="profitTargetPercent" min="0.1" max="20" step="0.1" value="4">
                </div>

                <button class="btn btn-primary" onclick="showLogs()" style="width: 100%; margin-top: 15px;">
                    View Logs
                </button>

                <div class="logs-panel" id="logsPanel">
                    <div id="logEntries"></div>
                </div>
            </div>

            <div class="watchlist-panel">
                <div class="section-title">Live Watchlist</div>

                <div class="watchlist-controls">
                    <button class="watchlist-btn" onclick="refreshWatchlist()">Refresh</button>
                    <button class="watchlist-btn" onclick="editWatchlist()">Edit</button>
                </div>

                <div class="watchlist-container" id="watchlistContainer">
                    <div class="watchlist-item">
                        <div class="watchlist-ticker">Loading...</div>
                        <div class="watchlist-price">$0.00</div>
                    </div>
                </div>
            </div>

            <div class="scanner-panel">
                <div class="section-title">Market Scanner</div>

                <div class="scanner-controls">
                    <textarea id="scannerCode" class="scanner-code-area" placeholder="# Enter your ThinkOrSwim scanning code:
# Example 1 - RSI Oversold:
# def rsi = RSI(length = 14);
# def volume_avg = Average(volume, 20);
# rsi < 30 and volume > volume_avg * 1.5;
#
# Example 2 - MACD Bullish:
# def macd = MACD();
# def price_sma = Average(close, 20);
# macd.Value > macd.Avg and close > price_sma;
#
# Example 3 - Breakout Pattern:
# def high20 = Highest(high, 20);
# def vol_avg = Average(volume, 10);
# close > high20[1] and volume > vol_avg * 2;"></textarea>

                    <button class="scanner-btn" id="scanBtn" onclick="startScanning()">Start Scan</button>
                    <button class="scanner-btn" onclick="stopScanning()">Stop Scan</button>
                </div>

                <div class="scan-status" id="scanStatus">
                    Ready to scan. Enter criteria above.
                </div>

                <div class="scanner-container" id="scannerContainer">
                    <div class="scanner-item">
                        <div class="scanner-ticker">No scans yet</div>
                        <div style="font-size: 12px; opacity: 0.8;">Enter criteria and click Start Scan</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        var API_BASE_URL = window.location.origin;
        var currentTicker = '';
        var isConnected = false;
        var isAutoTrading = false;
        var isHoldMode = false;
        var emergencyStopActive = false;
        var currentTimeframe = '1m';
        var customStrategy = '';
        var priceData = {};
        var multiTimeframeData = {};
        var indicators = {};
        var activeTrades = [];
        var totalPnL = 0;
        var realizedPnL = 0;
        var unrealizedPnL = 0;
        var autoTradingInterval = null;

        var watchlistStocks = ['AAPL', 'TSLA', 'GOOGL', 'MSFT', 'NVDA', 'META', 'AMZN', 'SPY', 'QQQ', 'AMD'];
        var watchlistData = {};

        var isScanning = false;
        var scanningInterval = null;
        var scannerCode = '';
        var scannedStocks = [];
        var allStocks = [
            'AAPL', 'TSLA', 'GOOGL', 'MSFT', 'NVDA', 'META', 'AMZN', 'NFLX', 'AMD', 'CRM',
            'SPY', 'QQQ', 'IWM', 'DIA', 'ARKK', 'TQQQ', 'SQQQ', 'VTI', 'VOO', 'VEA',
            'PLTR', 'COIN', 'RBLX', 'HOOD', 'SOFI', 'GME', 'AMC', 'BB', 'NOK', 'SNDL',
            'F', 'GE', 'BAC', 'JPM', 'WFC', 'V', 'MA', 'KO', 'PEP', 'DIS', 'NKE',
            'BABA', 'TSM', 'ASML', 'INTC', 'CSCO', 'ORCL', 'ADBE', 'PYPL', 'AVGO', 'TXN'
        ];
        var scannerResults = {};

        var POPULAR_STOCKS = [
            'AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA', 'META', 'NVDA', 'NFLX', 'AMD', 'CRM',
            'SPY', 'QQQ', 'IWM', 'DIA', 'ARKK', 'TQQQ', 'SQQQ', 'SPXL', 'UPRO', 'TMF'
        ];

        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
        });

        function initializeApp() {
            loadStockList();
            setupEventListeners();
            checkAPIConnection();
            startRealTimeUpdates();
            initializeWatchlist();
            addLog('System initialized', 'success');
        }

        function loadStockList() {
            var tickerSelect = document.getElementById('ticker');
            tickerSelect.innerHTML = '<option value="">Choose a stock...</option>';

            for (var i = 0; i < POPULAR_STOCKS.length; i++) {
                var option = document.createElement('option');
                option.value = POPULAR_STOCKS[i];
                option.textContent = POPULAR_STOCKS[i];
                tickerSelect.appendChild(option);
            }

            addLog('Stock list loaded', 'info');
        }

        function setupEventListeners() {
            document.getElementById('ticker').addEventListener('change', function() {
                if (this.value) {
                    document.getElementById('customTicker').value = '';
                    currentTicker = this.value;
                    addLog('Selected ticker: ' + currentTicker, 'info');
                    updateMarketData(currentTicker);
                }
            });

            document.getElementById('customTicker').addEventListener('input', function() {
                var customValue = this.value.toUpperCase().trim();
                if (customValue) {
                    document.getElementById('ticker').value = '';
                    currentTicker = customValue;
                    addLog('Custom ticker entered: ' + currentTicker, 'info');

                    if (customValue.length >= 1) {
                        updateMarketData(currentTicker);
                    }
                }
            });

            var chartBtns = document.querySelectorAll('.chart-btn');
            for (var i = 0; i < chartBtns.length; i++) {
                chartBtns[i].addEventListener('click', function() {
                    var allBtns = document.querySelectorAll('.chart-btn');
                    for (var j = 0; j < allBtns.length; j++) {
                        allBtns[j].classList.remove('active');
                    }
                    this.classList.add('active');
                    currentTimeframe = this.dataset.timeframe;
                    addLog('Changed timeframe to: ' + currentTimeframe, 'info');
                });
            }
        }

        function checkAPIConnection() {
            fetch(API_BASE_URL + '/api/health')
                .then(function(response) {
                    if (response.ok) {
                        isConnected = true;
                        updateConnectionStatus('Online');
                        addLog('API connected', 'success');
                    } else {
                        throw new Error('API check failed');
                    }
                })
                .catch(function(error) {
                    isConnected = false;
                    updateConnectionStatus('Offline');
                    addLog('API connection failed', 'error');
                });
        }

        function updateConnectionStatus(status) {
            var statusElement = document.getElementById('connectionStatus');
            if (status === 'Online') {
                statusElement.textContent = 'Online';
                statusElement.className = 'connection-status connection-online';
            } else {
                statusElement.textContent = 'Offline';
                statusElement.className = 'connection-status connection-offline';
            }
        }

        function startRealTimeUpdates() {
            setInterval(function() {
                if (currentTicker && isConnected) {
                    updateMarketData(currentTicker);
                }
            }, 5000);

            setInterval(function() {
                if (activeTrades.length > 0) {
                    updatePnLDisplay();
                }
            }, 10000);

            setInterval(function() {
                if (isAutoTrading && currentTicker && customStrategy) {
                    checkTradingSignals();
                }
            }, 30000);

            setInterval(function() {
                if (isConnected) {
                    updateWatchlist();
                }
            }, 3000);

            setInterval(function() {
                if (isScanning && isConnected) {
                    runMarketScan();
                }
            }, 10000);
        }

        function updateMarketData(symbol) {
            if (!isConnected) return;

            # Fetch data for all required timeframes
            var timeframes = ['1m', '5m', '15m', '4h'];
            var dataPromises = [];

            for (var i = 0; i < timeframes.length; i++) {
                var tf = timeframes[i];
                dataPromises.push(
                    fetch(API_BASE_URL + '/api/market-data/' + symbol + '?timeframe=' + tf)
                        .then(function(response) { return response.json(); })
                        .catch(function(error) {
                            # Fallback to simulated multi-timeframe data
                            return generateSimulatedTimeframeData(symbol, tf);
                        })
                );
            }

            Promise.all(dataPromises)
                .then(function(results) {
                    # Organize data by timeframe
                    multiTimeframeData = {};
                    for (var i = 0; i < timeframes.length; i++) {
                        multiTimeframeData[timeframes[i]] = results[i];
                    }

                    # Use 1m data as primary for display
                    var primaryData = multiTimeframeData['1m'];
                    if (primaryData && primaryData.currentPrice) {
                        updateMultiTimeframeIndicators(primaryData);

                        # Store price data for charting
                        if (!priceData[symbol]) priceData[symbol] = [];
                        priceData[symbol].push({
                            time: new Date(),
                            price: primaryData.currentPrice,
                            volume: primaryData.volume
                        });

                        # Keep only last 100 data points per symbol
                        if (priceData[symbol].length > 100) {
                            priceData[symbol] = priceData[symbol].slice(-100);
                        }

                        updateChart();
                    }
                })
                .catch(function(error) {
                    addLog('Multi-timeframe data error: ' + error.message, 'error');
                });
        }

        function generateSimulatedTimeframeData(symbol, timeframe) {
            # Generate simulated multi-timeframe data
            var basePrice = 150 + Math.random() * 50;
            var volatility = timeframe === '1m' ? 1 : timeframe === '5m' ? 2 : timeframe === '15m' ? 3 : 5;

            return {
                symbol: symbol,
                timeframe: timeframe,
                currentPrice: basePrice + (Math.random() - 0.5) * volatility,
                rsi: 30 + Math.random() * 40,
                macd: {
                    macd: (Math.random() - 0.5) * 2,
                    signal: (Math.random() - 0.5) * 1.5,
                    histogram: (Math.random() - 0.5) * 0.5
                },
                sma20: basePrice * (0.98 + Math.random() * 0.04),
                volume: Math.floor(Math.random() * 1000000),
                high: basePrice + Math.random() * 2,
                low: basePrice - Math.random() * 2,
                open: basePrice + (Math.random() - 0.5) * 1
            };
        }

        function updateMultiTimeframeIndicators(primaryData) {
            indicators = primaryData;

            # Update primary price display
            document.getElementById('currentPrice').textContent = '

        function updateChart() {
            var currentSymbolData = priceData[currentTicker];
            if (!currentSymbolData || currentSymbolData.length === 0) return;

            var canvas = document.getElementById('priceChart');
            var ctx = canvas.getContext('2d');

            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (currentSymbolData.length < 2) return;

            var prices = currentSymbolData.map(function(d) { return d.price; });
            var minPrice = Math.min.apply(Math, prices);
            var maxPrice = Math.max.apply(Math, prices);
            var priceRange = maxPrice - minPrice || 1;

            ctx.strokeStyle = '#4facfe';
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (var i = 0; i < currentSymbolData.length; i++) {
                var x = (i / (currentSymbolData.length - 1)) * canvas.width;
                var y = canvas.height - ((currentSymbolData[i].price - minPrice) / priceRange) * canvas.height;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.stroke();

            # Add timeframe indicator
            ctx.fillStyle = '#4facfe';
            ctx.font = '12px Arial';
            ctx.fillText('Timeframe: ' + currentTimeframe, 10, 20);
        }

        function executeTrade(action) {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!isConnected) {
                alert('API connection lost');
                return;
            }

            var quantity = parseInt(document.getElementById('quantity').value);
            var currentPrice = indicators.currentPrice || 100;

            var orderData = {
                symbol: currentTicker,
                action: action.toUpperCase(),
                quantity: quantity,
                orderType: 'MARKET',
                timeInForce: 'DAY',
                price: currentPrice
            };

            fetch(API_BASE_URL + '/api/orders', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(orderData)
            })
            .then(function(response) {
                return response.json();
            })
            .then(function(result) {
                if (result.success) {
                    addLog(action.toUpperCase() + ' order executed: ' + quantity + ' shares at $' + currentPrice.toFixed(2), 'success');

                    var trade = {
                        id: Date.now(),
                        symbol: currentTicker,
                        action: action.toUpperCase(),
                        quantity: quantity,
                        entryPrice: currentPrice,
                        timestamp: new Date(),
                        status: 'OPEN'
                    };

                    if (action.toUpperCase() === 'BUY') {
                        activeTrades.push(trade);
                    } else {
                        var existingTrade = null;
                        for (var i = 0; i < activeTrades.length; i++) {
                            if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                                existingTrade = activeTrades[i];
                                break;
                            }
                        }

                        if (existingTrade) {
                            existingTrade.status = 'CLOSED';
                            existingTrade.exitPrice = currentPrice;
                            var profit = (currentPrice - existingTrade.entryPrice) * existingTrade.quantity;
                            realizedPnL += profit;
                            addLog('Position closed: ' + (profit > 0 ? '+' : '') + '$' + profit.toFixed(2), profit > 0 ? 'success' : 'error');
                        }
                    }

                    updateActiveTradesDisplay();
                    updatePnLDisplay();
                    alert(action.toUpperCase() + ' order submitted successfully!');
                } else {
                    throw new Error(result.error);
                }
            })
            .catch(function(error) {
                addLog('Trade failed: ' + error.message, 'error');
                alert('Trade failed: ' + error.message);
            });
        }

        function cancelAllOrders() {
            addLog('All orders cancelled', 'warning');
            alert('All orders cancelled');
        }

        function setStopLoss() {
            var stopLossPercent = document.getElementById('stopLossPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var stopPrice = currentPrice * (1 - stopLossPercent / 100);

            addLog('Stop loss set at $' + stopPrice.toFixed(2), 'warning');
            alert('Stop loss set at $' + stopPrice.toFixed(2));
        }

        function setProfitTarget() {
            var profitTargetPercent = document.getElementById('profitTargetPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var targetPrice = currentPrice * (1 + profitTargetPercent / 100);

            addLog('Profit target set at $' + targetPrice.toFixed(2), 'success');
            alert('Profit target set at $' + targetPrice.toFixed(2));
        }

        function toggleAutomation() {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            isAutoTrading = !isAutoTrading;
            var toggleBtn = document.getElementById('toggleAuto');
            var statusIndicator = document.getElementById('autoStatus');
            var statusText = document.getElementById('autoStatusText');

            if (isAutoTrading) {
                toggleBtn.textContent = 'Stop Auto Trading';
                toggleBtn.className = 'btn btn-danger';
                statusIndicator.className = 'status-indicator status-active';
                statusText.textContent = 'Active';
                addLog('Auto trading started', 'success');

                autoTradingInterval = setInterval(function() {
                    checkTradingSignals();
                }, 30000);

            } else {
                toggleBtn.textContent = 'Start Auto Trading';
                toggleBtn.className = 'btn btn-primary';
                statusIndicator.className = 'status-indicator status-inactive';
                statusText.textContent = 'Inactive';
                addLog('Auto trading stopped', 'warning');

                if (autoTradingInterval) {
                    clearInterval(autoTradingInterval);
                    autoTradingInterval = null;
                }
            }
        }

        function loadStrategy() {
            var strategyCode = document.getElementById('customScript').value.trim();
            if (!strategyCode) {
                alert('Please enter a strategy first');
                return;
            }

            customStrategy = strategyCode;
            addLog('Strategy loaded', 'success');
            alert('Strategy loaded successfully!');
        }

        function testStrategy() {
            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            if (!indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            try {
                var result = evaluateCustomStrategy(indicators);
                addLog('Strategy test result: ' + result, 'info');
                alert('Strategy test result: ' + result);
            } catch (error) {
                addLog('Strategy test failed', 'error');
                alert('Strategy test failed');
            }
        }

        function clearStrategy() {
            customStrategy = '';
            document.getElementById('customScript').value = '';
            addLog('Strategy cleared', 'info');
        }

        function evaluateMultiTimeframeStrategy(timeframeData, strategy) {
            if (!strategy) return 'N/A';

            try {
                # Extract data from all timeframes
                var data_1m = timeframeData['1m'] || {};
                var data_5m = timeframeData['5m'] || {};
                var data_15m = timeframeData['15m'] || {};
                var data_4h = timeframeData['4h'] || {};

                # Convert ThinkOrSwim multi-timeframe syntax to JavaScript
                var jsCode = strategy
                    # Handle aggregationPeriod references
                    .replace(/RSI\(length\s*=\s*(\d+),\s*aggregationPeriod\s*=\s*AggregationPeriod\.MIN\)/g, function(match, length) {
                        return data_1m.rsi || 50;
                    })
                    .replace(/RSI\(length\s*=\s*(\d+),\s*aggregationPeriod\s*=\s*AggregationPeriod\.FIVE_MIN\)/g, function(match, length) {
                        return data_5m.rsi || 50;
                    })
                    .replace(/RSI\(length\s*=\s*(\d+),\s*aggregationPeriod\s*=\s*AggregationPeriod\.FIFTEEN_MIN\)/g, function(match, length) {
                        return data_15m.rsi || 50;
                    })
                    .replace(/RSI\(length\s*=\s*(\d+),\s*aggregationPeriod\s*=\s*AggregationPeriod\.FOUR_HOURS\)/g, function(match, length) {
                        return data_4h.rsi || 50;
                    })

                    # Handle MACD with timeframes
                    .replace(/MACD\(aggregationPeriod\s*=\s*AggregationPeriod\.MIN\)/g, function() {
                        var macd = data_1m.macd || {macd: 0, signal: 0};
                        return '{Value: ' + macd.macd + ', Avg: ' + macd.signal + '}';
                    })
                    .replace(/MACD\(aggregationPeriod\s*=\s*AggregationPeriod\.FIFTEEN_MIN\)/g, function() {
                        var macd = data_15m.macd || {macd: 0, signal: 0};
                        return '{Value: ' + macd.macd + ', Avg: ' + macd.signal + '}';
                    })

                    # Handle Average (SMA) with timeframes
                    .replace(/Average\(close,\s*(\d+),\s*aggregationPeriod\s*=\s*AggregationPeriod\.FOUR_HOURS\)/g, function(match, period) {
                        return data_4h.sma20 || data_4h.currentPrice || 100;
                    })

                    # Handle def statements
                    .replace(/def\s+(\w+)\s*=/g, 'var $1 =')

                    # Handle basic price references
                    .replace(/\bclose\b/g, data_1m.currentPrice || 100)
                    .replace(/\bhigh\b/g, data_1m.high || data_1m.currentPrice || 100)
                    .replace(/\blow\b/g, data_1m.low || data_1m.currentPrice || 100)
                    .replace(/\bvolume\b/g, data_1m.volume || 0)

                    # Handle logical operators
                    .replace(/\band\b/g, '&&')
                    .replace(/\bor\b/g, '||')
                    .replace(/\bnot\b/g, '!')

                    # Remove comments (only # comments as per your note)
                    .replace(/#.*$/gm, '')
                    .replace(/\s+/g, ' ')
                    .trim();

                # Look for BUY_CONDITION and SELL_CONDITION
                var lines = jsCode.split(';');
                var buyCondition = false;
                var sellCondition = false;

                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i].trim();
                    if (line.indexOf('BUY_CONDITION') !== -1) {
                        # Extract and evaluate buy condition
                        var condition = line.split('=')[1];
                        if (condition) {
                            try {
                                buyCondition = eval(condition.trim());
                            } catch (e) {
                                buyCondition = evaluateConditionPatterns(condition, timeframeData);
                            }
                        }
                    }
                    if (line.indexOf('SELL_CONDITION') !== -1) {
                        # Extract and evaluate sell condition
                        var condition = line.split('=')[1];
                        if (condition) {
                            try {
                                sellCondition = eval(condition.trim());
                            } catch (e) {
                                sellCondition = evaluateConditionPatterns(condition, timeframeData);
                            }
                        }
                    }
                }

                # Return signal based on conditions
                if (buyCondition) return 'BUY';
                if (sellCondition) return 'SELL';
                return 'HOLD';

            } catch (error) {
                console.log('Multi-timeframe strategy evaluation error:', error);
                return 'ERROR';
            }
        }

        function evaluateConditionPatterns(condition, timeframeData) {
            # Pattern matching for complex multi-timeframe conditions
            var data_1m = timeframeData['1m'] || {};
            var data_5m = timeframeData['5m'] || {};
            var data_15m = timeframeData['15m'] || {};
            var data_4h = timeframeData['4h'] || {};

            # Check for trend alignment
            if (condition.indexOf('trend_bullish') !== -1) {
                var currentPrice = data_1m.currentPrice || 100;
                var sma20_4h = data_4h.sma20 || currentPrice;
                return currentPrice > sma20_4h;
            }

            # Check for momentum conditions
            if (condition.indexOf('momentum') !== -1) {
                var macd_15m = data_15m.macd || {macd: 0, signal: 0};
                return macd_15m.macd > macd_15m.signal;
            }

            # Check for oversold conditions
            if (condition.indexOf('oversold') !== -1) {
                return (data_5m.rsi || 50) < 30;
            }

            # Check for entry conditions
            if (condition.indexOf('entry') !== -1) {
                return (data_1m.rsi || 50) < 25;
            }

            return false;
        }

        function checkTradingSignals() {
            if (!isAutoTrading || !currentTicker || !customStrategy) return;

            try {
                # Use multi-timeframe evaluation
                var signal = evaluateMultiTimeframeStrategy(multiTimeframeData, customStrategy);

                if (signal === 'BUY' || signal === 'SELL') {
                    addLog('Multi-timeframe auto signal: ' + signal + ' for ' + currentTicker, 'info');

                    var hasPosition = false;
                    for (var i = 0; i < activeTrades.length; i++) {
                        if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                            hasPosition = true;
                            break;
                        }
                    }

                    if (signal === 'BUY' && !hasPosition) {
                        addLog('Multi-timeframe BUY signal confirmed across timeframes', 'success');
                        executeTrade('buy');
                    } else if (signal === 'SELL' && hasPosition) {
                        addLog('Multi-timeframe SELL signal confirmed across timeframes', 'warning');
                        executeTrade('sell');
                    }
                }
            } catch (error) {
                addLog('Multi-timeframe signal check failed: ' + error.message, 'error');
            }
        }
                     + primaryData.currentPrice.toFixed(2);
            document.getElementById('volume').textContent = (primaryData.volume || 0).toLocaleString();

            # Update multi-timeframe RSI indicators
            if (multiTimeframeData['1m']) {
                document.getElementById('rsi_1m').textContent = (multiTimeframeData['1m'].rsi || 0).toFixed(2);
            }
            if (multiTimeframeData['5m']) {
                document.getElementById('rsi_5m').textContent = (multiTimeframeData['5m'].rsi || 0).toFixed(2);
            }
            if (multiTimeframeData['15m']) {
                document.getElementById('rsi_15m').textContent = (multiTimeframeData['15m'].rsi || 0).toFixed(2);
            }

            # Update multi-timeframe MACD indicators
            if (multiTimeframeData['1m'] && multiTimeframeData['1m'].macd) {
                document.getElementById('macd_1m').textContent = multiTimeframeData['1m'].macd.macd.toFixed(4);
            }
            if (multiTimeframeData['15m'] && multiTimeframeData['15m'].macd) {
                document.getElementById('macd_15m').textContent = multiTimeframeData['15m'].macd.macd.toFixed(4);
            }

            # Update 4-hour SMA
            if (multiTimeframeData['4h']) {
                document.getElementById('sma20_4h').textContent = '

        function updateChart() {
            if (priceData.length === 0) return;

            var canvas = document.getElementById('priceChart');
            var ctx = canvas.getContext('2d');

            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (priceData.length < 2) return;

            var prices = priceData.map(function(d) { return d.price; });
            var minPrice = Math.min.apply(Math, prices);
            var maxPrice = Math.max.apply(Math, prices);
            var priceRange = maxPrice - minPrice || 1;

            ctx.strokeStyle = '#4facfe';
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (var i = 0; i < priceData.length; i++) {
                var x = (i / (priceData.length - 1)) * canvas.width;
                var y = canvas.height - ((priceData[i].price - minPrice) / priceRange) * canvas.height;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.stroke();
        }

        function executeTrade(action) {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!isConnected) {
                alert('API connection lost');
                return;
            }

            var quantity = parseInt(document.getElementById('quantity').value);
            var currentPrice = indicators.currentPrice || 100;

            var orderData = {
                symbol: currentTicker,
                action: action.toUpperCase(),
                quantity: quantity,
                orderType: 'MARKET',
                timeInForce: 'DAY',
                price: currentPrice
            };

            fetch(API_BASE_URL + '/api/orders', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(orderData)
            })
            .then(function(response) {
                return response.json();
            })
            .then(function(result) {
                if (result.success) {
                    addLog(action.toUpperCase() + ' order executed: ' + quantity + ' shares at $' + currentPrice.toFixed(2), 'success');

                    var trade = {
                        id: Date.now(),
                        symbol: currentTicker,
                        action: action.toUpperCase(),
                        quantity: quantity,
                        entryPrice: currentPrice,
                        timestamp: new Date(),
                        status: 'OPEN'
                    };

                    if (action.toUpperCase() === 'BUY') {
                        activeTrades.push(trade);
                    } else {
                        var existingTrade = null;
                        for (var i = 0; i < activeTrades.length; i++) {
                            if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                                existingTrade = activeTrades[i];
                                break;
                            }
                        }

                        if (existingTrade) {
                            existingTrade.status = 'CLOSED';
                            existingTrade.exitPrice = currentPrice;
                            var profit = (currentPrice - existingTrade.entryPrice) * existingTrade.quantity;
                            realizedPnL += profit;
                            addLog('Position closed: ' + (profit > 0 ? '+' : '') + '$' + profit.toFixed(2), profit > 0 ? 'success' : 'error');
                        }
                    }

                    updateActiveTradesDisplay();
                    updatePnLDisplay();
                    alert(action.toUpperCase() + ' order submitted successfully!');
                } else {
                    throw new Error(result.error);
                }
            })
            .catch(function(error) {
                addLog('Trade failed: ' + error.message, 'error');
                alert('Trade failed: ' + error.message);
            });
        }

        function cancelAllOrders() {
            addLog('All orders cancelled', 'warning');
            alert('All orders cancelled');
        }

        function setStopLoss() {
            var stopLossPercent = document.getElementById('stopLossPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var stopPrice = currentPrice * (1 - stopLossPercent / 100);

            addLog('Stop loss set at $' + stopPrice.toFixed(2), 'warning');
            alert('Stop loss set at $' + stopPrice.toFixed(2));
        }

        function setProfitTarget() {
            var profitTargetPercent = document.getElementById('profitTargetPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var targetPrice = currentPrice * (1 + profitTargetPercent / 100);

            addLog('Profit target set at $' + targetPrice.toFixed(2), 'success');
            alert('Profit target set at $' + targetPrice.toFixed(2));
        }

        function toggleAutomation() {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            isAutoTrading = !isAutoTrading;
            var toggleBtn = document.getElementById('toggleAuto');
            var statusIndicator = document.getElementById('autoStatus');
            var statusText = document.getElementById('autoStatusText');

            if (isAutoTrading) {
                toggleBtn.textContent = 'Stop Auto Trading';
                toggleBtn.className = 'btn btn-danger';
                statusIndicator.className = 'status-indicator status-active';
                statusText.textContent = 'Active';
                addLog('Auto trading started', 'success');

                autoTradingInterval = setInterval(function() {
                    checkTradingSignals();
                }, 30000);

            } else {
                toggleBtn.textContent = 'Start Auto Trading';
                toggleBtn.className = 'btn btn-primary';
                statusIndicator.className = 'status-indicator status-inactive';
                statusText.textContent = 'Inactive';
                addLog('Auto trading stopped', 'warning');

                if (autoTradingInterval) {
                    clearInterval(autoTradingInterval);
                    autoTradingInterval = null;
                }
            }
        }

        function loadStrategy() {
            var strategyCode = document.getElementById('customScript').value.trim();
            if (!strategyCode) {
                alert('Please enter a strategy first');
                return;
            }

            customStrategy = strategyCode;
            addLog('Strategy loaded', 'success');
            alert('Strategy loaded successfully!');
        }

        function testStrategy() {
            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            if (!indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            try {
                var result = evaluateCustomStrategy(indicators);
                addLog('Strategy test result: ' + result, 'info');
                alert('Strategy test result: ' + result);
            } catch (error) {
                addLog('Strategy test failed', 'error');
                alert('Strategy test failed');
            }
        }

        function clearStrategy() {
            customStrategy = '';
            document.getElementById('customScript').value = '';
            addLog('Strategy cleared', 'info');
        }

        function evaluateCustomStrategy(data) {
            if (!customStrategy) return 'N/A';

            try {
                var rsi = data.rsi || 50;
                var macd = data.macd ? data.macd.macd : 0;
                var price = data.currentPrice || 100;

                if (customStrategy.indexOf('rsi < 30') !== -1 && rsi < 30) {
                    return 'BUY';
                }
                if (customStrategy.indexOf('rsi > 70') !== -1 && rsi > 70) {
                    return 'SELL';
                }

                return 'HOLD';
            } catch (error) {
                throw new Error('Strategy evaluation failed');
            }
        }

        function checkTradingSignals() {
            if (!isAutoTrading || !currentTicker || !customStrategy) return;

            try {
                var signal = evaluateCustomStrategy(indicators);

                if (signal === 'BUY' || signal === 'SELL') {
                    addLog('Auto signal: ' + signal, 'info');

                    var hasPosition = false;
                    for (var i = 0; i < activeTrades.length; i++) {
                        if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                            hasPosition = true;
                            break;
                        }
                    }
                     + (multiTimeframeData['4h'].sma20 || 0).toFixed(2);
            }

            # Update signal display
            var signal = primaryData.signal || 'HOLD';
            var signalDisplay = document.getElementById('signalDisplay');
            var signalText = document.getElementById('signalText');

            signalText.textContent = signal;
            signalDisplay.className = 'signal-display signal-' + signal.toLowerCase();

            # Evaluate custom multi-timeframe strategy
            if (customStrategy) {
                try {
                    var customResult = evaluateMultiTimeframeStrategy(multiTimeframeData, customStrategy);
                    document.getElementById('customIndicatorValue').textContent = customResult;
                } catch (error) {
                    document.getElementById('customIndicatorValue').textContent = 'Error';
                    addLog('Multi-timeframe strategy error: ' + error.message, 'error');
                }
            }
        }

        function updateChart() {
            if (priceData.length === 0) return;

            var canvas = document.getElementById('priceChart');
            var ctx = canvas.getContext('2d');

            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (priceData.length < 2) return;

            var prices = priceData.map(function(d) { return d.price; });
            var minPrice = Math.min.apply(Math, prices);
            var maxPrice = Math.max.apply(Math, prices);
            var priceRange = maxPrice - minPrice || 1;

            ctx.strokeStyle = '#4facfe';
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (var i = 0; i < priceData.length; i++) {
                var x = (i / (priceData.length - 1)) * canvas.width;
                var y = canvas.height - ((priceData[i].price - minPrice) / priceRange) * canvas.height;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.stroke();
        }

        function executeTrade(action) {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!isConnected) {
                alert('API connection lost');
                return;
            }

            var quantity = parseInt(document.getElementById('quantity').value);
            var currentPrice = indicators.currentPrice || 100;

            var orderData = {
                symbol: currentTicker,
                action: action.toUpperCase(),
                quantity: quantity,
                orderType: 'MARKET',
                timeInForce: 'DAY',
                price: currentPrice
            };

            fetch(API_BASE_URL + '/api/orders', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(orderData)
            })
            .then(function(response) {
                return response.json();
            })
            .then(function(result) {
                if (result.success) {
                    addLog(action.toUpperCase() + ' order executed: ' + quantity + ' shares at $' + currentPrice.toFixed(2), 'success');

                    var trade = {
                        id: Date.now(),
                        symbol: currentTicker,
                        action: action.toUpperCase(),
                        quantity: quantity,
                        entryPrice: currentPrice,
                        timestamp: new Date(),
                        status: 'OPEN'
                    };

                    if (action.toUpperCase() === 'BUY') {
                        activeTrades.push(trade);
                    } else {
                        var existingTrade = null;
                        for (var i = 0; i < activeTrades.length; i++) {
                            if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                                existingTrade = activeTrades[i];
                                break;
                            }
                        }

                        if (existingTrade) {
                            existingTrade.status = 'CLOSED';
                            existingTrade.exitPrice = currentPrice;
                            var profit = (currentPrice - existingTrade.entryPrice) * existingTrade.quantity;
                            realizedPnL += profit;
                            addLog('Position closed: ' + (profit > 0 ? '+' : '') + '$' + profit.toFixed(2), profit > 0 ? 'success' : 'error');
                        }
                    }

                    updateActiveTradesDisplay();
                    updatePnLDisplay();
                    alert(action.toUpperCase() + ' order submitted successfully!');
                } else {
                    throw new Error(result.error);
                }
            })
            .catch(function(error) {
                addLog('Trade failed: ' + error.message, 'error');
                alert('Trade failed: ' + error.message);
            });
        }

        function cancelAllOrders() {
            addLog('All orders cancelled', 'warning');
            alert('All orders cancelled');
        }

        function setStopLoss() {
            var stopLossPercent = document.getElementById('stopLossPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var stopPrice = currentPrice * (1 - stopLossPercent / 100);

            addLog('Stop loss set at $' + stopPrice.toFixed(2), 'warning');
            alert('Stop loss set at $' + stopPrice.toFixed(2));
        }

        function setProfitTarget() {
            var profitTargetPercent = document.getElementById('profitTargetPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var targetPrice = currentPrice * (1 + profitTargetPercent / 100);

            addLog('Profit target set at $' + targetPrice.toFixed(2), 'success');
            alert('Profit target set at $' + targetPrice.toFixed(2));
        }

        function toggleAutomation() {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            isAutoTrading = !isAutoTrading;
            var toggleBtn = document.getElementById('toggleAuto');
            var statusIndicator = document.getElementById('autoStatus');
            var statusText = document.getElementById('autoStatusText');

            if (isAutoTrading) {
                toggleBtn.textContent = 'Stop Auto Trading';
                toggleBtn.className = 'btn btn-danger';
                statusIndicator.className = 'status-indicator status-active';
                statusText.textContent = 'Active';
                addLog('Auto trading started', 'success');

                autoTradingInterval = setInterval(function() {
                    checkTradingSignals();
                }, 30000);

            } else {
                toggleBtn.textContent = 'Start Auto Trading';
                toggleBtn.className = 'btn btn-primary';
                statusIndicator.className = 'status-indicator status-inactive';
                statusText.textContent = 'Inactive';
                addLog('Auto trading stopped', 'warning');

                if (autoTradingInterval) {
                    clearInterval(autoTradingInterval);
                    autoTradingInterval = null;
                }
            }
        }

        function loadStrategy() {
            var strategyCode = document.getElementById('customScript').value.trim();
            if (!strategyCode) {
                alert('Please enter a strategy first');
                return;
            }

            customStrategy = strategyCode;
            addLog('Strategy loaded', 'success');
            alert('Strategy loaded successfully!');
        }

        function testStrategy() {
            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            if (!indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            try {
                var result = evaluateCustomStrategy(indicators);
                addLog('Strategy test result: ' + result, 'info');
                alert('Strategy test result: ' + result);
            } catch (error) {
                addLog('Strategy test failed', 'error');
                alert('Strategy test failed');
            }
        }

        function clearStrategy() {
            customStrategy = '';
            document.getElementById('customScript').value = '';
            addLog('Strategy cleared', 'info');
        }

        function evaluateCustomStrategy(data) {
            if (!customStrategy) return 'N/A';

            try {
                var rsi = data.rsi || 50;
                var macd = data.macd ? data.macd.macd : 0;
                var price = data.currentPrice || 100;

                if (customStrategy.indexOf('rsi < 30') !== -1 && rsi < 30) {
                    return 'BUY';
                }
                if (customStrategy.indexOf('rsi > 70') !== -1 && rsi > 70) {
                    return 'SELL';
                }

                return 'HOLD';
            } catch (error) {
                throw new Error('Strategy evaluation failed');
            }
        }

        function checkTradingSignals() {
            if (!isAutoTrading || !currentTicker || !customStrategy) return;

            try {
                var signal = evaluateCustomStrategy(indicators);

                if (signal === 'BUY' || signal === 'SELL') {
                    addLog('Auto signal: ' + signal, 'info');

                    var hasPosition = false;
                    for (var i = 0; i < activeTrades.length; i++) {
                        if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                            hasPosition = true;
                            break;
                        }
                    }
                     + currentPrice.toFixed(2), 'success');

                    var trade = {
                        id: Date.now(),
                        symbol: currentTicker,
                        action: action.toUpperCase(),
                        quantity: quantity,
                        entryPrice: currentPrice,
                        timestamp: new Date(),
                        status: 'OPEN'
                    };

                    if (action.toUpperCase() === 'BUY') {
                        activeTrades.push(trade);
                    } else {
                        var existingTrade = null;
                        for (var i = 0; i < activeTrades.length; i++) {
                            if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                                existingTrade = activeTrades[i];
                                break;
                            }
                        }

                        if (existingTrade) {
                            existingTrade.status = 'CLOSED';
                            existingTrade.exitPrice = currentPrice;
                            var profit = (currentPrice - existingTrade.entryPrice) * existingTrade.quantity;
                            realizedPnL += profit;
                            addLog('Position closed: ' + (profit > 0 ? '+' : '') + '

        function cancelAllOrders() {
            addLog('All orders cancelled', 'warning');
            alert('All orders cancelled');
        }

        function setStopLoss() {
            var stopLossPercent = document.getElementById('stopLossPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var stopPrice = currentPrice * (1 - stopLossPercent / 100);

            addLog('Stop loss set at $' + stopPrice.toFixed(2), 'warning');
            alert('Stop loss set at $' + stopPrice.toFixed(2));
        }

        function setProfitTarget() {
            var profitTargetPercent = document.getElementById('profitTargetPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var targetPrice = currentPrice * (1 + profitTargetPercent / 100);

            addLog('Profit target set at $' + targetPrice.toFixed(2), 'success');
            alert('Profit target set at $' + targetPrice.toFixed(2));
        }

        function toggleAutomation() {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            isAutoTrading = !isAutoTrading;
            var toggleBtn = document.getElementById('toggleAuto');
            var statusIndicator = document.getElementById('autoStatus');
            var statusText = document.getElementById('autoStatusText');

            if (isAutoTrading) {
                toggleBtn.textContent = 'Stop Auto Trading';
                toggleBtn.className = 'btn btn-danger';
                statusIndicator.className = 'status-indicator status-active';
                statusText.textContent = 'Active';
                addLog('Auto trading started', 'success');

                autoTradingInterval = setInterval(function() {
                    checkTradingSignals();
                }, 30000);

            } else {
                toggleBtn.textContent = 'Start Auto Trading';
                toggleBtn.className = 'btn btn-primary';
                statusIndicator.className = 'status-indicator status-inactive';
                statusText.textContent = 'Inactive';
                addLog('Auto trading stopped', 'warning');

                if (autoTradingInterval) {
                    clearInterval(autoTradingInterval);
                    autoTradingInterval = null;
                }
            }
        }

        function loadStrategy() {
            var strategyCode = document.getElementById('customScript').value.trim();
            if (!strategyCode) {
                alert('Please enter a strategy first');
                return;
            }

            customStrategy = strategyCode;
            addLog('Strategy loaded', 'success');
            alert('Strategy loaded successfully!');
        }

        function testStrategy() {
            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            if (!indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            try {
                var result = evaluateCustomStrategy(indicators);
                addLog('Strategy test result: ' + result, 'info');
                alert('Strategy test result: ' + result);
            } catch (error) {
                addLog('Strategy test failed', 'error');
                alert('Strategy test failed');
            }
        }

        function clearStrategy() {
            customStrategy = '';
            document.getElementById('customScript').value = '';
            addLog('Strategy cleared', 'info');
        }

        function evaluateMultiTimeframeStrategy(timeframeData, strategy) {
            if (!strategy) return 'N/A';

            try {
                # Extract data from all timeframes
                var data_1m = timeframeData['1m'] || {};
                var data_5m = timeframeData['5m'] || {};
                var data_15m = timeframeData['15m'] || {};
                var data_4h = timeframeData['4h'] || {};

                # Convert ThinkOrSwim multi-timeframe syntax to JavaScript
                var jsCode = strategy
                    # Handle aggregationPeriod references
                    .replace(/RSI\(length\s*=\s*(\d+),\s*aggregationPeriod\s*=\s*AggregationPeriod\.MIN\)/g, function(match, length) {
                        return data_1m.rsi || 50;
                    })
                    .replace(/RSI\(length\s*=\s*(\d+),\s*aggregationPeriod\s*=\s*AggregationPeriod\.FIVE_MIN\)/g, function(match, length) {
                        return data_5m.rsi || 50;
                    })
                    .replace(/RSI\(length\s*=\s*(\d+),\s*aggregationPeriod\s*=\s*AggregationPeriod\.FIFTEEN_MIN\)/g, function(match, length) {
                        return data_15m.rsi || 50;
                    })
                    .replace(/RSI\(length\s*=\s*(\d+),\s*aggregationPeriod\s*=\s*AggregationPeriod\.FOUR_HOURS\)/g, function(match, length) {
                        return data_4h.rsi || 50;
                    })

                    # Handle MACD with timeframes
                    .replace(/MACD\(aggregationPeriod\s*=\s*AggregationPeriod\.MIN\)/g, function() {
                        var macd = data_1m.macd || {macd: 0, signal: 0};
                        return '{Value: ' + macd.macd + ', Avg: ' + macd.signal + '}';
                    })
                    .replace(/MACD\(aggregationPeriod\s*=\s*AggregationPeriod\.FIFTEEN_MIN\)/g, function() {
                        var macd = data_15m.macd || {macd: 0, signal: 0};
                        return '{Value: ' + macd.macd + ', Avg: ' + macd.signal + '}';
                    })

                    # Handle Average (SMA) with timeframes
                    .replace(/Average\(close,\s*(\d+),\s*aggregationPeriod\s*=\s*AggregationPeriod\.FOUR_HOURS\)/g, function(match, period) {
                        return data_4h.sma20 || data_4h.currentPrice || 100;
                    })

                    # Handle def statements
                    .replace(/def\s+(\w+)\s*=/g, 'var $1 =')

                    # Handle basic price references
                    .replace(/\bclose\b/g, data_1m.currentPrice || 100)
                    .replace(/\bhigh\b/g, data_1m.high || data_1m.currentPrice || 100)
                    .replace(/\blow\b/g, data_1m.low || data_1m.currentPrice || 100)
                    .replace(/\bvolume\b/g, data_1m.volume || 0)

                    # Handle logical operators
                    .replace(/\band\b/g, '&&')
                    .replace(/\bor\b/g, '||')
                    .replace(/\bnot\b/g, '!')

                    # Remove comments (only # comments as per your note)
                    .replace(/#.*$/gm, '')
                    .replace(/\s+/g, ' ')
                    .trim();

                # Look for BUY_CONDITION and SELL_CONDITION
                var lines = jsCode.split(';');
                var buyCondition = false;
                var sellCondition = false;

                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i].trim();
                    if (line.indexOf('BUY_CONDITION') !== -1) {
                        # Extract and evaluate buy condition
                        var condition = line.split('=')[1];
                        if (condition) {
                            try {
                                buyCondition = eval(condition.trim());
                            } catch (e) {
                                buyCondition = evaluateConditionPatterns(condition, timeframeData);
                            }
                        }
                    }
                    if (line.indexOf('SELL_CONDITION') !== -1) {
                        # Extract and evaluate sell condition
                        var condition = line.split('=')[1];
                        if (condition) {
                            try {
                                sellCondition = eval(condition.trim());
                            } catch (e) {
                                sellCondition = evaluateConditionPatterns(condition, timeframeData);
                            }
                        }
                    }
                }

                # Return signal based on conditions
                if (buyCondition) return 'BUY';
                if (sellCondition) return 'SELL';
                return 'HOLD';

            } catch (error) {
                console.log('Multi-timeframe strategy evaluation error:', error);
                return 'ERROR';
            }
        }

        function evaluateConditionPatterns(condition, timeframeData) {
            # Pattern matching for complex multi-timeframe conditions
            var data_1m = timeframeData['1m'] || {};
            var data_5m = timeframeData['5m'] || {};
            var data_15m = timeframeData['15m'] || {};
            var data_4h = timeframeData['4h'] || {};

            # Check for trend alignment
            if (condition.indexOf('trend_bullish') !== -1) {
                var currentPrice = data_1m.currentPrice || 100;
                var sma20_4h = data_4h.sma20 || currentPrice;
                return currentPrice > sma20_4h;
            }

            # Check for momentum conditions
            if (condition.indexOf('momentum') !== -1) {
                var macd_15m = data_15m.macd || {macd: 0, signal: 0};
                return macd_15m.macd > macd_15m.signal;
            }

            # Check for oversold conditions
            if (condition.indexOf('oversold') !== -1) {
                return (data_5m.rsi || 50) < 30;
            }

            # Check for entry conditions
            if (condition.indexOf('entry') !== -1) {
                return (data_1m.rsi || 50) < 25;
            }

            return false;
        }

        function checkTradingSignals() {
            if (!isAutoTrading || !currentTicker || !customStrategy) return;

            try {
                # Use multi-timeframe evaluation
                var signal = evaluateMultiTimeframeStrategy(multiTimeframeData, customStrategy);

                if (signal === 'BUY' || signal === 'SELL') {
                    addLog('Multi-timeframe auto signal: ' + signal + ' for ' + currentTicker, 'info');

                    var hasPosition = false;
                    for (var i = 0; i < activeTrades.length; i++) {
                        if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                            hasPosition = true;
                            break;
                        }
                    }

                    if (signal === 'BUY' && !hasPosition) {
                        addLog('Multi-timeframe BUY signal confirmed across timeframes', 'success');
                        executeTrade('buy');
                    } else if (signal === 'SELL' && hasPosition) {
                        addLog('Multi-timeframe SELL signal confirmed across timeframes', 'warning');
                        executeTrade('sell');
                    }
                }
            } catch (error) {
                addLog('Multi-timeframe signal check failed: ' + error.message, 'error');
            }
        }
                     + primaryData.currentPrice.toFixed(2);
            document.getElementById('volume').textContent = (primaryData.volume || 0).toLocaleString();

            # Update multi-timeframe RSI indicators
            if (multiTimeframeData['1m']) {
                document.getElementById('rsi_1m').textContent = (multiTimeframeData['1m'].rsi || 0).toFixed(2);
            }
            if (multiTimeframeData['5m']) {
                document.getElementById('rsi_5m').textContent = (multiTimeframeData['5m'].rsi || 0).toFixed(2);
            }
            if (multiTimeframeData['15m']) {
                document.getElementById('rsi_15m').textContent = (multiTimeframeData['15m'].rsi || 0).toFixed(2);
            }

            # Update multi-timeframe MACD indicators
            if (multiTimeframeData['1m'] && multiTimeframeData['1m'].macd) {
                document.getElementById('macd_1m').textContent = multiTimeframeData['1m'].macd.macd.toFixed(4);
            }
            if (multiTimeframeData['15m'] && multiTimeframeData['15m'].macd) {
                document.getElementById('macd_15m').textContent = multiTimeframeData['15m'].macd.macd.toFixed(4);
            }

            # Update 4-hour SMA
            if (multiTimeframeData['4h']) {
                document.getElementById('sma20_4h').textContent = '

        function updateChart() {
            if (priceData.length === 0) return;

            var canvas = document.getElementById('priceChart');
            var ctx = canvas.getContext('2d');

            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (priceData.length < 2) return;

            var prices = priceData.map(function(d) { return d.price; });
            var minPrice = Math.min.apply(Math, prices);
            var maxPrice = Math.max.apply(Math, prices);
            var priceRange = maxPrice - minPrice || 1;

            ctx.strokeStyle = '#4facfe';
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (var i = 0; i < priceData.length; i++) {
                var x = (i / (priceData.length - 1)) * canvas.width;
                var y = canvas.height - ((priceData[i].price - minPrice) / priceRange) * canvas.height;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.stroke();
        }

        function executeTrade(action) {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!isConnected) {
                alert('API connection lost');
                return;
            }

            var quantity = parseInt(document.getElementById('quantity').value);
            var currentPrice = indicators.currentPrice || 100;

            var orderData = {
                symbol: currentTicker,
                action: action.toUpperCase(),
                quantity: quantity,
                orderType: 'MARKET',
                timeInForce: 'DAY',
                price: currentPrice
            };

            fetch(API_BASE_URL + '/api/orders', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(orderData)
            })
            .then(function(response) {
                return response.json();
            })
            .then(function(result) {
                if (result.success) {
                    addLog(action.toUpperCase() + ' order executed: ' + quantity + ' shares at $' + currentPrice.toFixed(2), 'success');

                    var trade = {
                        id: Date.now(),
                        symbol: currentTicker,
                        action: action.toUpperCase(),
                        quantity: quantity,
                        entryPrice: currentPrice,
                        timestamp: new Date(),
                        status: 'OPEN'
                    };

                    if (action.toUpperCase() === 'BUY') {
                        activeTrades.push(trade);
                    } else {
                        var existingTrade = null;
                        for (var i = 0; i < activeTrades.length; i++) {
                            if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                                existingTrade = activeTrades[i];
                                break;
                            }
                        }

                        if (existingTrade) {
                            existingTrade.status = 'CLOSED';
                            existingTrade.exitPrice = currentPrice;
                            var profit = (currentPrice - existingTrade.entryPrice) * existingTrade.quantity;
                            realizedPnL += profit;
                            addLog('Position closed: ' + (profit > 0 ? '+' : '') + '$' + profit.toFixed(2), profit > 0 ? 'success' : 'error');
                        }
                    }

                    updateActiveTradesDisplay();
                    updatePnLDisplay();
                    alert(action.toUpperCase() + ' order submitted successfully!');
                } else {
                    throw new Error(result.error);
                }
            })
            .catch(function(error) {
                addLog('Trade failed: ' + error.message, 'error');
                alert('Trade failed: ' + error.message);
            });
        }

        function cancelAllOrders() {
            addLog('All orders cancelled', 'warning');
            alert('All orders cancelled');
        }

        function setStopLoss() {
            var stopLossPercent = document.getElementById('stopLossPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var stopPrice = currentPrice * (1 - stopLossPercent / 100);

            addLog('Stop loss set at $' + stopPrice.toFixed(2), 'warning');
            alert('Stop loss set at $' + stopPrice.toFixed(2));
        }

        function setProfitTarget() {
            var profitTargetPercent = document.getElementById('profitTargetPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var targetPrice = currentPrice * (1 + profitTargetPercent / 100);

            addLog('Profit target set at $' + targetPrice.toFixed(2), 'success');
            alert('Profit target set at $' + targetPrice.toFixed(2));
        }

        function toggleAutomation() {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            isAutoTrading = !isAutoTrading;
            var toggleBtn = document.getElementById('toggleAuto');
            var statusIndicator = document.getElementById('autoStatus');
            var statusText = document.getElementById('autoStatusText');

            if (isAutoTrading) {
                toggleBtn.textContent = 'Stop Auto Trading';
                toggleBtn.className = 'btn btn-danger';
                statusIndicator.className = 'status-indicator status-active';
                statusText.textContent = 'Active';
                addLog('Auto trading started', 'success');

                autoTradingInterval = setInterval(function() {
                    checkTradingSignals();
                }, 30000);

            } else {
                toggleBtn.textContent = 'Start Auto Trading';
                toggleBtn.className = 'btn btn-primary';
                statusIndicator.className = 'status-indicator status-inactive';
                statusText.textContent = 'Inactive';
                addLog('Auto trading stopped', 'warning');

                if (autoTradingInterval) {
                    clearInterval(autoTradingInterval);
                    autoTradingInterval = null;
                }
            }
        }

        function loadStrategy() {
            var strategyCode = document.getElementById('customScript').value.trim();
            if (!strategyCode) {
                alert('Please enter a strategy first');
                return;
            }

            customStrategy = strategyCode;
            addLog('Strategy loaded', 'success');
            alert('Strategy loaded successfully!');
        }

        function testStrategy() {
            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            if (!indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            try {
                var result = evaluateCustomStrategy(indicators);
                addLog('Strategy test result: ' + result, 'info');
                alert('Strategy test result: ' + result);
            } catch (error) {
                addLog('Strategy test failed', 'error');
                alert('Strategy test failed');
            }
        }

        function clearStrategy() {
            customStrategy = '';
            document.getElementById('customScript').value = '';
            addLog('Strategy cleared', 'info');
        }

        function evaluateCustomStrategy(data) {
            if (!customStrategy) return 'N/A';

            try {
                var rsi = data.rsi || 50;
                var macd = data.macd ? data.macd.macd : 0;
                var price = data.currentPrice || 100;

                if (customStrategy.indexOf('rsi < 30') !== -1 && rsi < 30) {
                    return 'BUY';
                }
                if (customStrategy.indexOf('rsi > 70') !== -1 && rsi > 70) {
                    return 'SELL';
                }

                return 'HOLD';
            } catch (error) {
                throw new Error('Strategy evaluation failed');
            }
        }

        function checkTradingSignals() {
            if (!isAutoTrading || !currentTicker || !customStrategy) return;

            try {
                var signal = evaluateCustomStrategy(indicators);

                if (signal === 'BUY' || signal === 'SELL') {
                    addLog('Auto signal: ' + signal, 'info');

                    var hasPosition = false;
                    for (var i = 0; i < activeTrades.length; i++) {
                        if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                            hasPosition = true;
                            break;
                        }
                    }
                     + (multiTimeframeData['4h'].sma20 || 0).toFixed(2);
            }

            # Update signal display
            var signal = primaryData.signal || 'HOLD';
            var signalDisplay = document.getElementById('signalDisplay');
            var signalText = document.getElementById('signalText');

            signalText.textContent = signal;
            signalDisplay.className = 'signal-display signal-' + signal.toLowerCase();

            # Evaluate custom multi-timeframe strategy
            if (customStrategy) {
                try {
                    var customResult = evaluateMultiTimeframeStrategy(multiTimeframeData, customStrategy);
                    document.getElementById('customIndicatorValue').textContent = customResult;
                } catch (error) {
                    document.getElementById('customIndicatorValue').textContent = 'Error';
                    addLog('Multi-timeframe strategy error: ' + error.message, 'error');
                }
            }
        }

        function updateChart() {
            if (priceData.length === 0) return;

            var canvas = document.getElementById('priceChart');
            var ctx = canvas.getContext('2d');

            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (priceData.length < 2) return;

            var prices = priceData.map(function(d) { return d.price; });
            var minPrice = Math.min.apply(Math, prices);
            var maxPrice = Math.max.apply(Math, prices);
            var priceRange = maxPrice - minPrice || 1;

            ctx.strokeStyle = '#4facfe';
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (var i = 0; i < priceData.length; i++) {
                var x = (i / (priceData.length - 1)) * canvas.width;
                var y = canvas.height - ((priceData[i].price - minPrice) / priceRange) * canvas.height;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.stroke();
        }

        function executeTrade(action) {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!isConnected) {
                alert('API connection lost');
                return;
            }

            var quantity = parseInt(document.getElementById('quantity').value);
            var currentPrice = indicators.currentPrice || 100;

            var orderData = {
                symbol: currentTicker,
                action: action.toUpperCase(),
                quantity: quantity,
                orderType: 'MARKET',
                timeInForce: 'DAY',
                price: currentPrice
            };

            fetch(API_BASE_URL + '/api/orders', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(orderData)
            })
            .then(function(response) {
                return response.json();
            })
            .then(function(result) {
                if (result.success) {
                    addLog(action.toUpperCase() + ' order executed: ' + quantity + ' shares at $' + currentPrice.toFixed(2), 'success');

                    var trade = {
                        id: Date.now(),
                        symbol: currentTicker,
                        action: action.toUpperCase(),
                        quantity: quantity,
                        entryPrice: currentPrice,
                        timestamp: new Date(),
                        status: 'OPEN'
                    };

                    if (action.toUpperCase() === 'BUY') {
                        activeTrades.push(trade);
                    } else {
                        var existingTrade = null;
                        for (var i = 0; i < activeTrades.length; i++) {
                            if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                                existingTrade = activeTrades[i];
                                break;
                            }
                        }

                        if (existingTrade) {
                            existingTrade.status = 'CLOSED';
                            existingTrade.exitPrice = currentPrice;
                            var profit = (currentPrice - existingTrade.entryPrice) * existingTrade.quantity;
                            realizedPnL += profit;
                            addLog('Position closed: ' + (profit > 0 ? '+' : '') + '$' + profit.toFixed(2), profit > 0 ? 'success' : 'error');
                        }
                    }

                    updateActiveTradesDisplay();
                    updatePnLDisplay();
                    alert(action.toUpperCase() + ' order submitted successfully!');
                } else {
                    throw new Error(result.error);
                }
            })
            .catch(function(error) {
                addLog('Trade failed: ' + error.message, 'error');
                alert('Trade failed: ' + error.message);
            });
        }

        function cancelAllOrders() {
            addLog('All orders cancelled', 'warning');
            alert('All orders cancelled');
        }

        function setStopLoss() {
            var stopLossPercent = document.getElementById('stopLossPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var stopPrice = currentPrice * (1 - stopLossPercent / 100);

            addLog('Stop loss set at $' + stopPrice.toFixed(2), 'warning');
            alert('Stop loss set at $' + stopPrice.toFixed(2));
        }

        function setProfitTarget() {
            var profitTargetPercent = document.getElementById('profitTargetPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var targetPrice = currentPrice * (1 + profitTargetPercent / 100);

            addLog('Profit target set at $' + targetPrice.toFixed(2), 'success');
            alert('Profit target set at $' + targetPrice.toFixed(2));
        }

        function toggleAutomation() {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            isAutoTrading = !isAutoTrading;
            var toggleBtn = document.getElementById('toggleAuto');
            var statusIndicator = document.getElementById('autoStatus');
            var statusText = document.getElementById('autoStatusText');

            if (isAutoTrading) {
                toggleBtn.textContent = 'Stop Auto Trading';
                toggleBtn.className = 'btn btn-danger';
                statusIndicator.className = 'status-indicator status-active';
                statusText.textContent = 'Active';
                addLog('Auto trading started', 'success');

                autoTradingInterval = setInterval(function() {
                    checkTradingSignals();
                }, 30000);

            } else {
                toggleBtn.textContent = 'Start Auto Trading';
                toggleBtn.className = 'btn btn-primary';
                statusIndicator.className = 'status-indicator status-inactive';
                statusText.textContent = 'Inactive';
                addLog('Auto trading stopped', 'warning');

                if (autoTradingInterval) {
                    clearInterval(autoTradingInterval);
                    autoTradingInterval = null;
                }
            }
        }

        function loadStrategy() {
            var strategyCode = document.getElementById('customScript').value.trim();
            if (!strategyCode) {
                alert('Please enter a strategy first');
                return;
            }

            customStrategy = strategyCode;
            addLog('Strategy loaded', 'success');
            alert('Strategy loaded successfully!');
        }

        function testStrategy() {
            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            if (!indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            try {
                var result = evaluateCustomStrategy(indicators);
                addLog('Strategy test result: ' + result, 'info');
                alert('Strategy test result: ' + result);
            } catch (error) {
                addLog('Strategy test failed', 'error');
                alert('Strategy test failed');
            }
        }

        function clearStrategy() {
            customStrategy = '';
            document.getElementById('customScript').value = '';
            addLog('Strategy cleared', 'info');
        }

        function evaluateCustomStrategy(data) {
            if (!customStrategy) return 'N/A';

            try {
                var rsi = data.rsi || 50;
                var macd = data.macd ? data.macd.macd : 0;
                var price = data.currentPrice || 100;

                if (customStrategy.indexOf('rsi < 30') !== -1 && rsi < 30) {
                    return 'BUY';
                }
                if (customStrategy.indexOf('rsi > 70') !== -1 && rsi > 70) {
                    return 'SELL';
                }

                return 'HOLD';
            } catch (error) {
                throw new Error('Strategy evaluation failed');
            }
        }

        function checkTradingSignals() {
            if (!isAutoTrading || !currentTicker || !customStrategy) return;

            try {
                var signal = evaluateCustomStrategy(indicators);

                if (signal === 'BUY' || signal === 'SELL') {
                    addLog('Auto signal: ' + signal, 'info');

                    var hasPosition = false;
                    for (var i = 0; i < activeTrades.length; i++) {
                        if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                            hasPosition = true;
                            break;
                        }
                    }
                     + realizedPnL.toFixed(2), 'info');
        }

        function executeSellOrder(symbol, quantity) {
            # Execute the actual sell order
            var orderData = {
                symbol: symbol,
                action: 'SELL',
                quantity: quantity,
                orderType: 'MARKET',
                timeInForce: 'DAY'
            };

            fetch(API_BASE_URL + '/api/orders', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(orderData)
            })
            .then(function(response) {
                return response.json();
            })
            .then(function(result) {
                addLog('Emergency sell executed: ' + symbol, 'success');
            })
            .catch(function(error) {
                addLog('Emergency sell failed for ' + symbol + ': ' + error.message, 'error');
            });
        }

        function emergencyStop() {
            emergencyStopActive = !emergencyStopActive;
            var emergencyBtn = event.target;

            if (emergencyStopActive) {
                # FULL EMERGENCY STOP
                emergencyBtn.textContent = 'Resume All';
                emergencyBtn.className = 'btn btn-danger';

                # Stop auto trading
                if (isAutoTrading) {
                    toggleAutomation();
                }

                # Activate hold mode
                if (!isHoldMode) {
                    toggleHoldMode();
                }

                # Close all positions
                closeAllPositions();

                # Cancel all pending orders
                cancelAllOrders();

                # Update status indicators
                var holdStatus = document.getElementById('holdStatus');
                holdStatus.className = 'status-indicator status-emergency';

                addLog('EMERGENCY STOP ACTIVATED - All trading halted, positions closed', 'error');
                alert('EMERGENCY STOP ACTIVATED!\\n\\n Auto trading stopped\\n All positions closed\\n All orders cancelled\\n System in HOLD mode');

            } else {
                # RESUME FROM EMERGENCY
                emergencyBtn.textContent = 'Emergency Stop';
                emergencyBtn.className = 'btn btn-secondary';

                # Deactivate hold mode
                if (isHoldMode) {
                    toggleHoldMode();
                }

                addLog('Emergency stop deactivated - System ready for trading', 'success');
                alert('Emergency stop deactivated.\\nSystem is ready for trading.\\nYou can now restart auto trading if desired.');
            }
        }

        function checkTradingPermissions() {
            # Check if trading is allowed based on current modes
            if (emergencyStopActive) {
                addLog('Trade blocked: Emergency stop is active', 'error');
                return false;
            }

            if (isHoldMode) {
                addLog('Trade blocked: HOLD mode is active', 'warning');
                return false;
            }

            return true;
        }
        @media (max-width: 1200px) {
            .main-grid { grid-template-columns: 1fr; }
            .watchlist-panel {
                order: 3;
                max-height: 180px;
            }
            .scanner-panel {
                order: 4;
                max-height: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Fynda Auto Trading BOT</h1>
            <div class="connection-status" id="connectionStatus">Connecting...</div>
        </div>

        <div class="main-grid">
            <div class="left-panel">
                <div class="section-title">Trading Controls</div>

                <div class="form-group">
                    <label for="ticker">Select Stock:</label>
                    <select id="ticker" required>
                        <option value="">Loading stocks...</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="customTicker">Or Enter Custom Stock Symbol:</label>
                    <input type="text" id="customTicker" placeholder="e.g., PLTR, COIN, GME" style="text-transform: uppercase;">
                </div>

                <div class="form-group">
                    <label for="quantity">Quantity:</label>
                    <input type="number" id="quantity" min="1" max="10000" value="100" required>
                </div>

                <div class="button-grid">
                    <button class="btn btn-buy" onclick="executeTrade('buy')">Buy</button>
                    <button class="btn btn-sell" onclick="executeTrade('sell')">Sell</button>
                </div>

                <div class="button-row">
                    <button class="btn btn-cancel" onclick="cancelAllOrders()">Cancel All</button>
                    <button class="btn btn-secondary" onclick="setStopLoss()">Stop Loss</button>
                    <button class="btn btn-success" onclick="setProfitTarget()">Profit Target</button>
                </div>

                <div class="button-row" style="margin-top: 10px;">
                    <button class="btn btn-primary" id="holdBtn" onclick="toggleHoldMode()">Force HOLD</button>
                    <button class="btn btn-danger" onclick="closeAllPositions()">Close All</button>
                    <button class="btn btn-secondary" onclick="emergencyStop()">Emergency Stop</button>
                </div>

                <div class="automation-panel">
                    <div class="automation-status">
                        <span>Auto Trading:</span>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div class="status-indicator status-inactive" id="autoStatus"></div>
                            <span id="autoStatusText">Inactive</span>
                        </div>
                    </div>
                    <div class="automation-status" style="margin-top: 8px;">
                        <span>Position Mode:</span>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div class="status-indicator status-inactive" id="holdStatus"></div>
                            <span id="holdStatusText">Trading</span>
                        </div>
                    </div>
                    <button class="btn btn-primary" id="toggleAuto" onclick="toggleAutomation()" style="width: 100%;">
                        Start Auto Trading
                    </button>
                </div>

                <div class="pnl-display">
                    <div class="indicator-label">Today's P&L</div>
                    <div class="pnl-value" id="totalPnL">$0.00</div>
                    <div style="display: flex; justify-content: space-between; font-size: 12px; margin-top: 8px;">
                        <span>Realized: <span id="realizedPnL">$0.00</span></span>
                        <span>Unrealized: <span id="unrealizedPnL">$0.00</span></span>
                    </div>
                </div>

                <div class="trades-panel">
                    <div class="indicator-label" style="margin-bottom: 10px;">Active Trades</div>
                    <div id="activeTradesList">No active trades</div>
                </div>
            </div>

            <div class="center-panel">
                <div class="section-title">Market Analysis</div>

                <div class="chart-controls">
                    <button class="chart-btn active" data-timeframe="1m">1M</button>
                    <button class="chart-btn" data-timeframe="5m">5M</button>
                    <button class="chart-btn" data-timeframe="15m">15M</button>
                    <button class="chart-btn" data-timeframe="1h">1H</button>
                </div>

                <div class="chart-container" id="chartContainer">
                    <canvas id="priceChart" style="width: 100%; height: 100%;"></canvas>
                </div>

                <div class="indicators-grid">
                    <div class="indicator-card">
                        <div class="indicator-value" id="currentPrice">$0.00</div>
                        <div class="indicator-label">Price (1m)</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="rsi_1m">0.00</div>
                        <div class="indicator-label">RSI (1m)</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="rsi_5m">0.00</div>
                        <div class="indicator-label">RSI (5m)</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="rsi_15m">0.00</div>
                        <div class="indicator-label">RSI (15m)</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="macd_1m">0.00</div>
                        <div class="indicator-label">MACD (1m)</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="macd_15m">0.00</div>
                        <div class="indicator-label">MACD (15m)</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="sma20_4h">0.00</div>
                        <div class="indicator-label">SMA20 (4h)</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="volume">0</div>
                        <div class="indicator-label">Volume</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="customIndicatorValue">N/A</div>
                        <div class="indicator-label">Strategy Signal</div>
                    </div>
                </div>

                <div class="signal-display" id="signalDisplay">
                    <div id="signalText">HOLD</div>
                </div>
            </div>

            <div class="right-panel">
                <div class="section-title">Custom Strategy</div>

                <div class="form-group">
                    <label for="customScript">ThinkOrSwim Multi-Timeframe Strategy:</label>
                    <textarea id="customScript" class="custom-script-area" placeholder="# ThinkOrSwim Multi-Timeframe Strategy Code
# This bot supports 1m, 5m, 15m, and 4h timeframe analysis
# Use aggregationPeriod to reference different timeframes
#
# Example Multi-Timeframe Strategy:
# def rsi_1m = RSI(length = 14, aggregationPeriod = AggregationPeriod.MIN);
# def rsi_5m = RSI(length = 14, aggregationPeriod = AggregationPeriod.FIVE_MIN);
# def rsi_15m = RSI(length = 14, aggregationPeriod = AggregationPeriod.FIFTEEN_MIN);
# def rsi_4h = RSI(length = 14, aggregationPeriod = AggregationPeriod.FOUR_HOURS);
#
# def macd_15m = MACD(aggregationPeriod = AggregationPeriod.FIFTEEN_MIN);
# def sma20_4h = Average(close, 20, aggregationPeriod = AggregationPeriod.FOUR_HOURS);
#
# # Multi-timeframe conditions
# def trend_bullish_4h = close > sma20_4h;
# def momentum_15m = macd_15m.Value > macd_15m.Avg;
# def oversold_5m = rsi_5m < 30;
# def entry_1m = rsi_1m < 25;
#
# # Combined entry signal
# BUY_CONDITION = trend_bullish_4h and momentum_15m and oversold_5m and entry_1m;
# SELL_CONDITION = rsi_1m > 75 or rsi_5m > 80;"></textarea>
                </div>

                <div class="button-row">
                    <button class="btn btn-primary" onclick="loadStrategy()">Load</button>
                    <button class="btn btn-secondary" onclick="testStrategy()">Test</button>
                    <button class="btn btn-danger" onclick="clearStrategy()">Clear</button>
                </div>

                <div class="form-group" style="margin-top: 15px;">
                    <label for="stopLossPercent">Stop Loss %:</label>
                    <input type="number" id="stopLossPercent" min="0.1" max="10" step="0.1" value="2">

                    <label for="profitTargetPercent">Profit Target %:</label>
                    <input type="number" id="profitTargetPercent" min="0.1" max="20" step="0.1" value="4">
                </div>

                <button class="btn btn-primary" onclick="showLogs()" style="width: 100%; margin-top: 15px;">
                    View Logs
                </button>

                <div class="logs-panel" id="logsPanel">
                    <div id="logEntries"></div>
                </div>
            </div>

            <div class="watchlist-panel">
                <div class="section-title">Live Watchlist</div>

                <div class="watchlist-controls">
                    <button class="watchlist-btn" onclick="refreshWatchlist()">Refresh</button>
                    <button class="watchlist-btn" onclick="editWatchlist()">Edit</button>
                </div>

                <div class="watchlist-container" id="watchlistContainer">
                    <div class="watchlist-item">
                        <div class="watchlist-ticker">Loading...</div>
                        <div class="watchlist-price">$0.00</div>
                    </div>
                </div>
            </div>

            <div class="scanner-panel">
                <div class="section-title">Market Scanner</div>

                <div class="scanner-controls">
                    <textarea id="scannerCode" class="scanner-code-area" placeholder="# Enter your ThinkOrSwim scanning code:
# Example 1 - RSI Oversold:
# def rsi = RSI(length = 14);
# def volume_avg = Average(volume, 20);
# rsi < 30 and volume > volume_avg * 1.5;
#
# Example 2 - MACD Bullish:
# def macd = MACD();
# def price_sma = Average(close, 20);
# macd.Value > macd.Avg and close > price_sma;
#
# Example 3 - Breakout Pattern:
# def high20 = Highest(high, 20);
# def vol_avg = Average(volume, 10);
# close > high20[1] and volume > vol_avg * 2;"></textarea>

                    <button class="scanner-btn" id="scanBtn" onclick="startScanning()">Start Scan</button>
                    <button class="scanner-btn" onclick="stopScanning()">Stop Scan</button>
                </div>

                <div class="scan-status" id="scanStatus">
                    Ready to scan. Enter criteria above.
                </div>

                <div class="scanner-container" id="scannerContainer">
                    <div class="scanner-item">
                        <div class="scanner-ticker">No scans yet</div>
                        <div style="font-size: 12px; opacity: 0.8;">Enter criteria and click Start Scan</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        var API_BASE_URL = window.location.origin;
        var currentTicker = '';
        var isConnected = false;
        var isAutoTrading = false;
        var isHoldMode = false;
        var emergencyStopActive = false;
        var currentTimeframe = '1m';
        var customStrategy = '';
        var priceData = {};
        var multiTimeframeData = {};
        var indicators = {};
        var activeTrades = [];
        var totalPnL = 0;
        var realizedPnL = 0;
        var unrealizedPnL = 0;
        var autoTradingInterval = null;

        var watchlistStocks = ['AAPL', 'TSLA', 'GOOGL', 'MSFT', 'NVDA', 'META', 'AMZN', 'SPY', 'QQQ', 'AMD'];
        var watchlistData = {};

        var isScanning = false;
        var scanningInterval = null;
        var scannerCode = '';
        var scannedStocks = [];
        var allStocks = [
            'AAPL', 'TSLA', 'GOOGL', 'MSFT', 'NVDA', 'META', 'AMZN', 'NFLX', 'AMD', 'CRM',
            'SPY', 'QQQ', 'IWM', 'DIA', 'ARKK', 'TQQQ', 'SQQQ', 'VTI', 'VOO', 'VEA',
            'PLTR', 'COIN', 'RBLX', 'HOOD', 'SOFI', 'GME', 'AMC', 'BB', 'NOK', 'SNDL',
            'F', 'GE', 'BAC', 'JPM', 'WFC', 'V', 'MA', 'KO', 'PEP', 'DIS', 'NKE',
            'BABA', 'TSM', 'ASML', 'INTC', 'CSCO', 'ORCL', 'ADBE', 'PYPL', 'AVGO', 'TXN'
        ];
        var scannerResults = {};

        var POPULAR_STOCKS = [
            'AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA', 'META', 'NVDA', 'NFLX', 'AMD', 'CRM',
            'SPY', 'QQQ', 'IWM', 'DIA', 'ARKK', 'TQQQ', 'SQQQ', 'SPXL', 'UPRO', 'TMF'
        ];

        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
        });

        function initializeApp() {
            loadStockList();
            setupEventListeners();
            checkAPIConnection();
            startRealTimeUpdates();
            initializeWatchlist();
            addLog('System initialized', 'success');
        }

        function loadStockList() {
            var tickerSelect = document.getElementById('ticker');
            tickerSelect.innerHTML = '<option value="">Choose a stock...</option>';

            for (var i = 0; i < POPULAR_STOCKS.length; i++) {
                var option = document.createElement('option');
                option.value = POPULAR_STOCKS[i];
                option.textContent = POPULAR_STOCKS[i];
                tickerSelect.appendChild(option);
            }

            addLog('Stock list loaded', 'info');
        }

        function setupEventListeners() {
            document.getElementById('ticker').addEventListener('change', function() {
                if (this.value) {
                    document.getElementById('customTicker').value = '';
                    currentTicker = this.value;
                    addLog('Selected ticker: ' + currentTicker, 'info');
                    updateMarketData(currentTicker);
                }
            });

            document.getElementById('customTicker').addEventListener('input', function() {
                var customValue = this.value.toUpperCase().trim();
                if (customValue) {
                    document.getElementById('ticker').value = '';
                    currentTicker = customValue;
                    addLog('Custom ticker entered: ' + currentTicker, 'info');

                    if (customValue.length >= 1) {
                        updateMarketData(currentTicker);
                    }
                }
            });

            var chartBtns = document.querySelectorAll('.chart-btn');
            for (var i = 0; i < chartBtns.length; i++) {
                chartBtns[i].addEventListener('click', function() {
                    var allBtns = document.querySelectorAll('.chart-btn');
                    for (var j = 0; j < allBtns.length; j++) {
                        allBtns[j].classList.remove('active');
                    }
                    this.classList.add('active');
                    currentTimeframe = this.dataset.timeframe;
                    addLog('Changed timeframe to: ' + currentTimeframe, 'info');
                });
            }
        }

        function checkAPIConnection() {
            fetch(API_BASE_URL + '/api/health')
                .then(function(response) {
                    if (response.ok) {
                        isConnected = true;
                        updateConnectionStatus('Online');
                        addLog('API connected', 'success');
                    } else {
                        throw new Error('API check failed');
                    }
                })
                .catch(function(error) {
                    isConnected = false;
                    updateConnectionStatus('Offline');
                    addLog('API connection failed', 'error');
                });
        }

        function updateConnectionStatus(status) {
            var statusElement = document.getElementById('connectionStatus');
            if (status === 'Online') {
                statusElement.textContent = 'Online';
                statusElement.className = 'connection-status connection-online';
            } else {
                statusElement.textContent = 'Offline';
                statusElement.className = 'connection-status connection-offline';
            }
        }

        function startRealTimeUpdates() {
            setInterval(function() {
                if (currentTicker && isConnected) {
                    updateMarketData(currentTicker);
                }
            }, 5000);

            setInterval(function() {
                if (activeTrades.length > 0) {
                    updatePnLDisplay();
                }
            }, 10000);

            setInterval(function() {
                if (isAutoTrading && currentTicker && customStrategy) {
                    checkTradingSignals();
                }
            }, 30000);

            setInterval(function() {
                if (isConnected) {
                    updateWatchlist();
                }
            }, 3000);

            setInterval(function() {
                if (isScanning && isConnected) {
                    runMarketScan();
                }
            }, 10000);
        }

        function updateMarketData(symbol) {
            if (!isConnected) return;

            # Fetch data for all required timeframes
            var timeframes = ['1m', '5m', '15m', '4h'];
            var dataPromises = [];

            for (var i = 0; i < timeframes.length; i++) {
                var tf = timeframes[i];
                dataPromises.push(
                    fetch(API_BASE_URL + '/api/market-data/' + symbol + '?timeframe=' + tf)
                        .then(function(response) { return response.json(); })
                        .catch(function(error) {
                            # Fallback to simulated multi-timeframe data
                            return generateSimulatedTimeframeData(symbol, tf);
                        })
                );
            }

            Promise.all(dataPromises)
                .then(function(results) {
                    # Organize data by timeframe
                    multiTimeframeData = {};
                    for (var i = 0; i < timeframes.length; i++) {
                        multiTimeframeData[timeframes[i]] = results[i];
                    }

                    # Use 1m data as primary for display
                    var primaryData = multiTimeframeData['1m'];
                    if (primaryData && primaryData.currentPrice) {
                        updateMultiTimeframeIndicators(primaryData);

                        # Store price data for charting
                        if (!priceData[symbol]) priceData[symbol] = [];
                        priceData[symbol].push({
                            time: new Date(),
                            price: primaryData.currentPrice,
                            volume: primaryData.volume
                        });

                        # Keep only last 100 data points per symbol
                        if (priceData[symbol].length > 100) {
                            priceData[symbol] = priceData[symbol].slice(-100);
                        }

                        updateChart();
                    }
                })
                .catch(function(error) {
                    addLog('Multi-timeframe data error: ' + error.message, 'error');
                });
        }

        function generateSimulatedTimeframeData(symbol, timeframe) {
            # Generate simulated multi-timeframe data
            var basePrice = 150 + Math.random() * 50;
            var volatility = timeframe === '1m' ? 1 : timeframe === '5m' ? 2 : timeframe === '15m' ? 3 : 5;

            return {
                symbol: symbol,
                timeframe: timeframe,
                currentPrice: basePrice + (Math.random() - 0.5) * volatility,
                rsi: 30 + Math.random() * 40,
                macd: {
                    macd: (Math.random() - 0.5) * 2,
                    signal: (Math.random() - 0.5) * 1.5,
                    histogram: (Math.random() - 0.5) * 0.5
                },
                sma20: basePrice * (0.98 + Math.random() * 0.04),
                volume: Math.floor(Math.random() * 1000000),
                high: basePrice + Math.random() * 2,
                low: basePrice - Math.random() * 2,
                open: basePrice + (Math.random() - 0.5) * 1
            };
        }

        function updateMultiTimeframeIndicators(primaryData) {
            indicators = primaryData;

            # Update primary price display
            document.getElementById('currentPrice').textContent = '

        function updateChart() {
            var currentSymbolData = priceData[currentTicker];
            if (!currentSymbolData || currentSymbolData.length === 0) return;

            var canvas = document.getElementById('priceChart');
            var ctx = canvas.getContext('2d');

            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (currentSymbolData.length < 2) return;

            var prices = currentSymbolData.map(function(d) { return d.price; });
            var minPrice = Math.min.apply(Math, prices);
            var maxPrice = Math.max.apply(Math, prices);
            var priceRange = maxPrice - minPrice || 1;

            ctx.strokeStyle = '#4facfe';
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (var i = 0; i < currentSymbolData.length; i++) {
                var x = (i / (currentSymbolData.length - 1)) * canvas.width;
                var y = canvas.height - ((currentSymbolData[i].price - minPrice) / priceRange) * canvas.height;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.stroke();

            # Add timeframe indicator
            ctx.fillStyle = '#4facfe';
            ctx.font = '12px Arial';
            ctx.fillText('Timeframe: ' + currentTimeframe, 10, 20);
        }

        function executeTrade(action) {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!isConnected) {
                alert('API connection lost');
                return;
            }

            var quantity = parseInt(document.getElementById('quantity').value);
            var currentPrice = indicators.currentPrice || 100;

            var orderData = {
                symbol: currentTicker,
                action: action.toUpperCase(),
                quantity: quantity,
                orderType: 'MARKET',
                timeInForce: 'DAY',
                price: currentPrice
            };

            fetch(API_BASE_URL + '/api/orders', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(orderData)
            })
            .then(function(response) {
                return response.json();
            })
            .then(function(result) {
                if (result.success) {
                    addLog(action.toUpperCase() + ' order executed: ' + quantity + ' shares at $' + currentPrice.toFixed(2), 'success');

                    var trade = {
                        id: Date.now(),
                        symbol: currentTicker,
                        action: action.toUpperCase(),
                        quantity: quantity,
                        entryPrice: currentPrice,
                        timestamp: new Date(),
                        status: 'OPEN'
                    };

                    if (action.toUpperCase() === 'BUY') {
                        activeTrades.push(trade);
                    } else {
                        var existingTrade = null;
                        for (var i = 0; i < activeTrades.length; i++) {
                            if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                                existingTrade = activeTrades[i];
                                break;
                            }
                        }

                        if (existingTrade) {
                            existingTrade.status = 'CLOSED';
                            existingTrade.exitPrice = currentPrice;
                            var profit = (currentPrice - existingTrade.entryPrice) * existingTrade.quantity;
                            realizedPnL += profit;
                            addLog('Position closed: ' + (profit > 0 ? '+' : '') + '$' + profit.toFixed(2), profit > 0 ? 'success' : 'error');
                        }
                    }

                    updateActiveTradesDisplay();
                    updatePnLDisplay();
                    alert(action.toUpperCase() + ' order submitted successfully!');
                } else {
                    throw new Error(result.error);
                }
            })
            .catch(function(error) {
                addLog('Trade failed: ' + error.message, 'error');
                alert('Trade failed: ' + error.message);
            });
        }

        function cancelAllOrders() {
            addLog('All orders cancelled', 'warning');
            alert('All orders cancelled');
        }

        function setStopLoss() {
            var stopLossPercent = document.getElementById('stopLossPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var stopPrice = currentPrice * (1 - stopLossPercent / 100);

            addLog('Stop loss set at $' + stopPrice.toFixed(2), 'warning');
            alert('Stop loss set at $' + stopPrice.toFixed(2));
        }

        function setProfitTarget() {
            var profitTargetPercent = document.getElementById('profitTargetPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var targetPrice = currentPrice * (1 + profitTargetPercent / 100);

            addLog('Profit target set at $' + targetPrice.toFixed(2), 'success');
            alert('Profit target set at $' + targetPrice.toFixed(2));
        }

        function toggleAutomation() {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            isAutoTrading = !isAutoTrading;
            var toggleBtn = document.getElementById('toggleAuto');
            var statusIndicator = document.getElementById('autoStatus');
            var statusText = document.getElementById('autoStatusText');

            if (isAutoTrading) {
                toggleBtn.textContent = 'Stop Auto Trading';
                toggleBtn.className = 'btn btn-danger';
                statusIndicator.className = 'status-indicator status-active';
                statusText.textContent = 'Active';
                addLog('Auto trading started', 'success');

                autoTradingInterval = setInterval(function() {
                    checkTradingSignals();
                }, 30000);

            } else {
                toggleBtn.textContent = 'Start Auto Trading';
                toggleBtn.className = 'btn btn-primary';
                statusIndicator.className = 'status-indicator status-inactive';
                statusText.textContent = 'Inactive';
                addLog('Auto trading stopped', 'warning');

                if (autoTradingInterval) {
                    clearInterval(autoTradingInterval);
                    autoTradingInterval = null;
                }
            }
        }

        function loadStrategy() {
            var strategyCode = document.getElementById('customScript').value.trim();
            if (!strategyCode) {
                alert('Please enter a strategy first');
                return;
            }

            customStrategy = strategyCode;
            addLog('Strategy loaded', 'success');
            alert('Strategy loaded successfully!');
        }

        function testStrategy() {
            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            if (!indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            try {
                var result = evaluateCustomStrategy(indicators);
                addLog('Strategy test result: ' + result, 'info');
                alert('Strategy test result: ' + result);
            } catch (error) {
                addLog('Strategy test failed', 'error');
                alert('Strategy test failed');
            }
        }

        function clearStrategy() {
            customStrategy = '';
            document.getElementById('customScript').value = '';
            addLog('Strategy cleared', 'info');
        }

        function evaluateMultiTimeframeStrategy(timeframeData, strategy) {
            if (!strategy) return 'N/A';

            try {
                # Extract data from all timeframes
                var data_1m = timeframeData['1m'] || {};
                var data_5m = timeframeData['5m'] || {};
                var data_15m = timeframeData['15m'] || {};
                var data_4h = timeframeData['4h'] || {};

                # Convert ThinkOrSwim multi-timeframe syntax to JavaScript
                var jsCode = strategy
                    # Handle aggregationPeriod references
                    .replace(/RSI\(length\s*=\s*(\d+),\s*aggregationPeriod\s*=\s*AggregationPeriod\.MIN\)/g, function(match, length) {
                        return data_1m.rsi || 50;
                    })
                    .replace(/RSI\(length\s*=\s*(\d+),\s*aggregationPeriod\s*=\s*AggregationPeriod\.FIVE_MIN\)/g, function(match, length) {
                        return data_5m.rsi || 50;
                    })
                    .replace(/RSI\(length\s*=\s*(\d+),\s*aggregationPeriod\s*=\s*AggregationPeriod\.FIFTEEN_MIN\)/g, function(match, length) {
                        return data_15m.rsi || 50;
                    })
                    .replace(/RSI\(length\s*=\s*(\d+),\s*aggregationPeriod\s*=\s*AggregationPeriod\.FOUR_HOURS\)/g, function(match, length) {
                        return data_4h.rsi || 50;
                    })

                    # Handle MACD with timeframes
                    .replace(/MACD\(aggregationPeriod\s*=\s*AggregationPeriod\.MIN\)/g, function() {
                        var macd = data_1m.macd || {macd: 0, signal: 0};
                        return '{Value: ' + macd.macd + ', Avg: ' + macd.signal + '}';
                    })
                    .replace(/MACD\(aggregationPeriod\s*=\s*AggregationPeriod\.FIFTEEN_MIN\)/g, function() {
                        var macd = data_15m.macd || {macd: 0, signal: 0};
                        return '{Value: ' + macd.macd + ', Avg: ' + macd.signal + '}';
                    })

                    # Handle Average (SMA) with timeframes
                    .replace(/Average\(close,\s*(\d+),\s*aggregationPeriod\s*=\s*AggregationPeriod\.FOUR_HOURS\)/g, function(match, period) {
                        return data_4h.sma20 || data_4h.currentPrice || 100;
                    })

                    # Handle def statements
                    .replace(/def\s+(\w+)\s*=/g, 'var $1 =')

                    # Handle basic price references
                    .replace(/\bclose\b/g, data_1m.currentPrice || 100)
                    .replace(/\bhigh\b/g, data_1m.high || data_1m.currentPrice || 100)
                    .replace(/\blow\b/g, data_1m.low || data_1m.currentPrice || 100)
                    .replace(/\bvolume\b/g, data_1m.volume || 0)

                    # Handle logical operators
                    .replace(/\band\b/g, '&&')
                    .replace(/\bor\b/g, '||')
                    .replace(/\bnot\b/g, '!')

                    # Remove comments (only # comments as per your note)
                    .replace(/#.*$/gm, '')
                    .replace(/\s+/g, ' ')
                    .trim();

                # Look for BUY_CONDITION and SELL_CONDITION
                var lines = jsCode.split(';');
                var buyCondition = false;
                var sellCondition = false;

                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i].trim();
                    if (line.indexOf('BUY_CONDITION') !== -1) {
                        # Extract and evaluate buy condition
                        var condition = line.split('=')[1];
                        if (condition) {
                            try {
                                buyCondition = eval(condition.trim());
                            } catch (e) {
                                buyCondition = evaluateConditionPatterns(condition, timeframeData);
                            }
                        }
                    }
                    if (line.indexOf('SELL_CONDITION') !== -1) {
                        # Extract and evaluate sell condition
                        var condition = line.split('=')[1];
                        if (condition) {
                            try {
                                sellCondition = eval(condition.trim());
                            } catch (e) {
                                sellCondition = evaluateConditionPatterns(condition, timeframeData);
                            }
                        }
                    }
                }

                # Return signal based on conditions
                if (buyCondition) return 'BUY';
                if (sellCondition) return 'SELL';
                return 'HOLD';

            } catch (error) {
                console.log('Multi-timeframe strategy evaluation error:', error);
                return 'ERROR';
            }
        }

        function evaluateConditionPatterns(condition, timeframeData) {
            # Pattern matching for complex multi-timeframe conditions
            var data_1m = timeframeData['1m'] || {};
            var data_5m = timeframeData['5m'] || {};
            var data_15m = timeframeData['15m'] || {};
            var data_4h = timeframeData['4h'] || {};

            # Check for trend alignment
            if (condition.indexOf('trend_bullish') !== -1) {
                var currentPrice = data_1m.currentPrice || 100;
                var sma20_4h = data_4h.sma20 || currentPrice;
                return currentPrice > sma20_4h;
            }

            # Check for momentum conditions
            if (condition.indexOf('momentum') !== -1) {
                var macd_15m = data_15m.macd || {macd: 0, signal: 0};
                return macd_15m.macd > macd_15m.signal;
            }

            # Check for oversold conditions
            if (condition.indexOf('oversold') !== -1) {
                return (data_5m.rsi || 50) < 30;
            }

            # Check for entry conditions
            if (condition.indexOf('entry') !== -1) {
                return (data_1m.rsi || 50) < 25;
            }

            return false;
        }

        function checkTradingSignals() {
            if (!isAutoTrading || !currentTicker || !customStrategy) return;

            try {
                # Use multi-timeframe evaluation
                var signal = evaluateMultiTimeframeStrategy(multiTimeframeData, customStrategy);

                if (signal === 'BUY' || signal === 'SELL') {
                    addLog('Multi-timeframe auto signal: ' + signal + ' for ' + currentTicker, 'info');

                    var hasPosition = false;
                    for (var i = 0; i < activeTrades.length; i++) {
                        if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                            hasPosition = true;
                            break;
                        }
                    }

                    if (signal === 'BUY' && !hasPosition) {
                        addLog('Multi-timeframe BUY signal confirmed across timeframes', 'success');
                        executeTrade('buy');
                    } else if (signal === 'SELL' && hasPosition) {
                        addLog('Multi-timeframe SELL signal confirmed across timeframes', 'warning');
                        executeTrade('sell');
                    }
                }
            } catch (error) {
                addLog('Multi-timeframe signal check failed: ' + error.message, 'error');
            }
        }
                     + primaryData.currentPrice.toFixed(2);
            document.getElementById('volume').textContent = (primaryData.volume || 0).toLocaleString();

            # Update multi-timeframe RSI indicators
            if (multiTimeframeData['1m']) {
                document.getElementById('rsi_1m').textContent = (multiTimeframeData['1m'].rsi || 0).toFixed(2);
            }
            if (multiTimeframeData['5m']) {
                document.getElementById('rsi_5m').textContent = (multiTimeframeData['5m'].rsi || 0).toFixed(2);
            }
            if (multiTimeframeData['15m']) {
                document.getElementById('rsi_15m').textContent = (multiTimeframeData['15m'].rsi || 0).toFixed(2);
            }

            # Update multi-timeframe MACD indicators
            if (multiTimeframeData['1m'] && multiTimeframeData['1m'].macd) {
                document.getElementById('macd_1m').textContent = multiTimeframeData['1m'].macd.macd.toFixed(4);
            }
            if (multiTimeframeData['15m'] && multiTimeframeData['15m'].macd) {
                document.getElementById('macd_15m').textContent = multiTimeframeData['15m'].macd.macd.toFixed(4);
            }

            # Update 4-hour SMA
            if (multiTimeframeData['4h']) {
                document.getElementById('sma20_4h').textContent = '

        function updateChart() {
            if (priceData.length === 0) return;

            var canvas = document.getElementById('priceChart');
            var ctx = canvas.getContext('2d');

            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (priceData.length < 2) return;

            var prices = priceData.map(function(d) { return d.price; });
            var minPrice = Math.min.apply(Math, prices);
            var maxPrice = Math.max.apply(Math, prices);
            var priceRange = maxPrice - minPrice || 1;

            ctx.strokeStyle = '#4facfe';
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (var i = 0; i < priceData.length; i++) {
                var x = (i / (priceData.length - 1)) * canvas.width;
                var y = canvas.height - ((priceData[i].price - minPrice) / priceRange) * canvas.height;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.stroke();
        }

        function executeTrade(action) {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!isConnected) {
                alert('API connection lost');
                return;
            }

            var quantity = parseInt(document.getElementById('quantity').value);
            var currentPrice = indicators.currentPrice || 100;

            var orderData = {
                symbol: currentTicker,
                action: action.toUpperCase(),
                quantity: quantity,
                orderType: 'MARKET',
                timeInForce: 'DAY',
                price: currentPrice
            };

            fetch(API_BASE_URL + '/api/orders', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(orderData)
            })
            .then(function(response) {
                return response.json();
            })
            .then(function(result) {
                if (result.success) {
                    addLog(action.toUpperCase() + ' order executed: ' + quantity + ' shares at $' + currentPrice.toFixed(2), 'success');

                    var trade = {
                        id: Date.now(),
                        symbol: currentTicker,
                        action: action.toUpperCase(),
                        quantity: quantity,
                        entryPrice: currentPrice,
                        timestamp: new Date(),
                        status: 'OPEN'
                    };

                    if (action.toUpperCase() === 'BUY') {
                        activeTrades.push(trade);
                    } else {
                        var existingTrade = null;
                        for (var i = 0; i < activeTrades.length; i++) {
                            if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                                existingTrade = activeTrades[i];
                                break;
                            }
                        }

                        if (existingTrade) {
                            existingTrade.status = 'CLOSED';
                            existingTrade.exitPrice = currentPrice;
                            var profit = (currentPrice - existingTrade.entryPrice) * existingTrade.quantity;
                            realizedPnL += profit;
                            addLog('Position closed: ' + (profit > 0 ? '+' : '') + '$' + profit.toFixed(2), profit > 0 ? 'success' : 'error');
                        }
                    }

                    updateActiveTradesDisplay();
                    updatePnLDisplay();
                    alert(action.toUpperCase() + ' order submitted successfully!');
                } else {
                    throw new Error(result.error);
                }
            })
            .catch(function(error) {
                addLog('Trade failed: ' + error.message, 'error');
                alert('Trade failed: ' + error.message);
            });
        }

        function cancelAllOrders() {
            addLog('All orders cancelled', 'warning');
            alert('All orders cancelled');
        }

        function setStopLoss() {
            var stopLossPercent = document.getElementById('stopLossPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var stopPrice = currentPrice * (1 - stopLossPercent / 100);

            addLog('Stop loss set at $' + stopPrice.toFixed(2), 'warning');
            alert('Stop loss set at $' + stopPrice.toFixed(2));
        }

        function setProfitTarget() {
            var profitTargetPercent = document.getElementById('profitTargetPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var targetPrice = currentPrice * (1 + profitTargetPercent / 100);

            addLog('Profit target set at $' + targetPrice.toFixed(2), 'success');
            alert('Profit target set at $' + targetPrice.toFixed(2));
        }

        function toggleAutomation() {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            isAutoTrading = !isAutoTrading;
            var toggleBtn = document.getElementById('toggleAuto');
            var statusIndicator = document.getElementById('autoStatus');
            var statusText = document.getElementById('autoStatusText');

            if (isAutoTrading) {
                toggleBtn.textContent = 'Stop Auto Trading';
                toggleBtn.className = 'btn btn-danger';
                statusIndicator.className = 'status-indicator status-active';
                statusText.textContent = 'Active';
                addLog('Auto trading started', 'success');

                autoTradingInterval = setInterval(function() {
                    checkTradingSignals();
                }, 30000);

            } else {
                toggleBtn.textContent = 'Start Auto Trading';
                toggleBtn.className = 'btn btn-primary';
                statusIndicator.className = 'status-indicator status-inactive';
                statusText.textContent = 'Inactive';
                addLog('Auto trading stopped', 'warning');

                if (autoTradingInterval) {
                    clearInterval(autoTradingInterval);
                    autoTradingInterval = null;
                }
            }
        }

        function loadStrategy() {
            var strategyCode = document.getElementById('customScript').value.trim();
            if (!strategyCode) {
                alert('Please enter a strategy first');
                return;
            }

            customStrategy = strategyCode;
            addLog('Strategy loaded', 'success');
            alert('Strategy loaded successfully!');
        }

        function testStrategy() {
            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            if (!indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            try {
                var result = evaluateCustomStrategy(indicators);
                addLog('Strategy test result: ' + result, 'info');
                alert('Strategy test result: ' + result);
            } catch (error) {
                addLog('Strategy test failed', 'error');
                alert('Strategy test failed');
            }
        }

        function clearStrategy() {
            customStrategy = '';
            document.getElementById('customScript').value = '';
            addLog('Strategy cleared', 'info');
        }

        function evaluateCustomStrategy(data) {
            if (!customStrategy) return 'N/A';

            try {
                var rsi = data.rsi || 50;
                var macd = data.macd ? data.macd.macd : 0;
                var price = data.currentPrice || 100;

                if (customStrategy.indexOf('rsi < 30') !== -1 && rsi < 30) {
                    return 'BUY';
                }
                if (customStrategy.indexOf('rsi > 70') !== -1 && rsi > 70) {
                    return 'SELL';
                }

                return 'HOLD';
            } catch (error) {
                throw new Error('Strategy evaluation failed');
            }
        }

        function checkTradingSignals() {
            if (!isAutoTrading || !currentTicker || !customStrategy) return;

            try {
                var signal = evaluateCustomStrategy(indicators);

                if (signal === 'BUY' || signal === 'SELL') {
                    addLog('Auto signal: ' + signal, 'info');

                    var hasPosition = false;
                    for (var i = 0; i < activeTrades.length; i++) {
                        if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                            hasPosition = true;
                            break;
                        }
                    }
                     + (multiTimeframeData['4h'].sma20 || 0).toFixed(2);
            }

            # Update signal display
            var signal = primaryData.signal || 'HOLD';
            var signalDisplay = document.getElementById('signalDisplay');
            var signalText = document.getElementById('signalText');

            signalText.textContent = signal;
            signalDisplay.className = 'signal-display signal-' + signal.toLowerCase();

            # Evaluate custom multi-timeframe strategy
            if (customStrategy) {
                try {
                    var customResult = evaluateMultiTimeframeStrategy(multiTimeframeData, customStrategy);
                    document.getElementById('customIndicatorValue').textContent = customResult;
                } catch (error) {
                    document.getElementById('customIndicatorValue').textContent = 'Error';
                    addLog('Multi-timeframe strategy error: ' + error.message, 'error');
                }
            }
        }

        function updateChart() {
            if (priceData.length === 0) return;

            var canvas = document.getElementById('priceChart');
            var ctx = canvas.getContext('2d');

            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (priceData.length < 2) return;

            var prices = priceData.map(function(d) { return d.price; });
            var minPrice = Math.min.apply(Math, prices);
            var maxPrice = Math.max.apply(Math, prices);
            var priceRange = maxPrice - minPrice || 1;

            ctx.strokeStyle = '#4facfe';
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (var i = 0; i < priceData.length; i++) {
                var x = (i / (priceData.length - 1)) * canvas.width;
                var y = canvas.height - ((priceData[i].price - minPrice) / priceRange) * canvas.height;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.stroke();
        }

        function executeTrade(action) {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!isConnected) {
                alert('API connection lost');
                return;
            }

            var quantity = parseInt(document.getElementById('quantity').value);
            var currentPrice = indicators.currentPrice || 100;

            var orderData = {
                symbol: currentTicker,
                action: action.toUpperCase(),
                quantity: quantity,
                orderType: 'MARKET',
                timeInForce: 'DAY',
                price: currentPrice
            };

            fetch(API_BASE_URL + '/api/orders', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(orderData)
            })
            .then(function(response) {
                return response.json();
            })
            .then(function(result) {
                if (result.success) {
                    addLog(action.toUpperCase() + ' order executed: ' + quantity + ' shares at $' + currentPrice.toFixed(2), 'success');

                    var trade = {
                        id: Date.now(),
                        symbol: currentTicker,
                        action: action.toUpperCase(),
                        quantity: quantity,
                        entryPrice: currentPrice,
                        timestamp: new Date(),
                        status: 'OPEN'
                    };

                    if (action.toUpperCase() === 'BUY') {
                        activeTrades.push(trade);
                    } else {
                        var existingTrade = null;
                        for (var i = 0; i < activeTrades.length; i++) {
                            if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                                existingTrade = activeTrades[i];
                                break;
                            }
                        }

                        if (existingTrade) {
                            existingTrade.status = 'CLOSED';
                            existingTrade.exitPrice = currentPrice;
                            var profit = (currentPrice - existingTrade.entryPrice) * existingTrade.quantity;
                            realizedPnL += profit;
                            addLog('Position closed: ' + (profit > 0 ? '+' : '') + '$' + profit.toFixed(2), profit > 0 ? 'success' : 'error');
                        }
                    }

                    updateActiveTradesDisplay();
                    updatePnLDisplay();
                    alert(action.toUpperCase() + ' order submitted successfully!');
                } else {
                    throw new Error(result.error);
                }
            })
            .catch(function(error) {
                addLog('Trade failed: ' + error.message, 'error');
                alert('Trade failed: ' + error.message);
            });
        }

        function cancelAllOrders() {
            addLog('All orders cancelled', 'warning');
            alert('All orders cancelled');
        }

        function setStopLoss() {
            var stopLossPercent = document.getElementById('stopLossPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var stopPrice = currentPrice * (1 - stopLossPercent / 100);

            addLog('Stop loss set at $' + stopPrice.toFixed(2), 'warning');
            alert('Stop loss set at $' + stopPrice.toFixed(2));
        }

        function setProfitTarget() {
            var profitTargetPercent = document.getElementById('profitTargetPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var targetPrice = currentPrice * (1 + profitTargetPercent / 100);

            addLog('Profit target set at $' + targetPrice.toFixed(2), 'success');
            alert('Profit target set at $' + targetPrice.toFixed(2));
        }

        function toggleAutomation() {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            isAutoTrading = !isAutoTrading;
            var toggleBtn = document.getElementById('toggleAuto');
            var statusIndicator = document.getElementById('autoStatus');
            var statusText = document.getElementById('autoStatusText');

            if (isAutoTrading) {
                toggleBtn.textContent = 'Stop Auto Trading';
                toggleBtn.className = 'btn btn-danger';
                statusIndicator.className = 'status-indicator status-active';
                statusText.textContent = 'Active';
                addLog('Auto trading started', 'success');

                autoTradingInterval = setInterval(function() {
                    checkTradingSignals();
                }, 30000);

            } else {
                toggleBtn.textContent = 'Start Auto Trading';
                toggleBtn.className = 'btn btn-primary';
                statusIndicator.className = 'status-indicator status-inactive';
                statusText.textContent = 'Inactive';
                addLog('Auto trading stopped', 'warning');

                if (autoTradingInterval) {
                    clearInterval(autoTradingInterval);
                    autoTradingInterval = null;
                }
            }
        }

        function loadStrategy() {
            var strategyCode = document.getElementById('customScript').value.trim();
            if (!strategyCode) {
                alert('Please enter a strategy first');
                return;
            }

            customStrategy = strategyCode;
            addLog('Strategy loaded', 'success');
            alert('Strategy loaded successfully!');
        }

        function testStrategy() {
            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            if (!indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            try {
                var result = evaluateCustomStrategy(indicators);
                addLog('Strategy test result: ' + result, 'info');
                alert('Strategy test result: ' + result);
            } catch (error) {
                addLog('Strategy test failed', 'error');
                alert('Strategy test failed');
            }
        }

        function clearStrategy() {
            customStrategy = '';
            document.getElementById('customScript').value = '';
            addLog('Strategy cleared', 'info');
        }

        function evaluateCustomStrategy(data) {
            if (!customStrategy) return 'N/A';

            try {
                var rsi = data.rsi || 50;
                var macd = data.macd ? data.macd.macd : 0;
                var price = data.currentPrice || 100;

                if (customStrategy.indexOf('rsi < 30') !== -1 && rsi < 30) {
                    return 'BUY';
                }
                if (customStrategy.indexOf('rsi > 70') !== -1 && rsi > 70) {
                    return 'SELL';
                }

                return 'HOLD';
            } catch (error) {
                throw new Error('Strategy evaluation failed');
            }
        }

        function checkTradingSignals() {
            if (!isAutoTrading || !currentTicker || !customStrategy) return;

            try {
                var signal = evaluateCustomStrategy(indicators);

                if (signal === 'BUY' || signal === 'SELL') {
                    addLog('Auto signal: ' + signal, 'info');

                    var hasPosition = false;
                    for (var i = 0; i < activeTrades.length; i++) {
                        if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                            hasPosition = true;
                            break;
                        }
                    }
                     + profit.toFixed(2), profit > 0 ? 'success' : 'error');
                        }
                    }

                    updateActiveTradesDisplay();
                    updatePnLDisplay();
                    alert(action.toUpperCase() + ' order submitted successfully!');
                } else {
                    throw new Error(result.error);
                }
            })
            .catch(function(error) {
                addLog('Trade failed: ' + error.message, 'error');
                alert('Trade failed: ' + error.message);
            });
        }

        function cancelAllOrders() {
            addLog('All orders cancelled', 'warning');
            alert('All orders cancelled');
        }

        function setStopLoss() {
            var stopLossPercent = document.getElementById('stopLossPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var stopPrice = currentPrice * (1 - stopLossPercent / 100);

            addLog('Stop loss set at $' + stopPrice.toFixed(2), 'warning');
            alert('Stop loss set at $' + stopPrice.toFixed(2));
        }

        function setProfitTarget() {
            var profitTargetPercent = document.getElementById('profitTargetPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var targetPrice = currentPrice * (1 + profitTargetPercent / 100);

            addLog('Profit target set at $' + targetPrice.toFixed(2), 'success');
            alert('Profit target set at $' + targetPrice.toFixed(2));
        }

        function toggleAutomation() {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            isAutoTrading = !isAutoTrading;
            var toggleBtn = document.getElementById('toggleAuto');
            var statusIndicator = document.getElementById('autoStatus');
            var statusText = document.getElementById('autoStatusText');

            if (isAutoTrading) {
                toggleBtn.textContent = 'Stop Auto Trading';
                toggleBtn.className = 'btn btn-danger';
                statusIndicator.className = 'status-indicator status-active';
                statusText.textContent = 'Active';
                addLog('Auto trading started', 'success');

                autoTradingInterval = setInterval(function() {
                    checkTradingSignals();
                }, 30000);

            } else {
                toggleBtn.textContent = 'Start Auto Trading';
                toggleBtn.className = 'btn btn-primary';
                statusIndicator.className = 'status-indicator status-inactive';
                statusText.textContent = 'Inactive';
                addLog('Auto trading stopped', 'warning');

                if (autoTradingInterval) {
                    clearInterval(autoTradingInterval);
                    autoTradingInterval = null;
                }
            }
        }

        function loadStrategy() {
            var strategyCode = document.getElementById('customScript').value.trim();
            if (!strategyCode) {
                alert('Please enter a strategy first');
                return;
            }

            customStrategy = strategyCode;
            addLog('Strategy loaded', 'success');
            alert('Strategy loaded successfully!');
        }

        function testStrategy() {
            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            if (!indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            try {
                var result = evaluateCustomStrategy(indicators);
                addLog('Strategy test result: ' + result, 'info');
                alert('Strategy test result: ' + result);
            } catch (error) {
                addLog('Strategy test failed', 'error');
                alert('Strategy test failed');
            }
        }

        function clearStrategy() {
            customStrategy = '';
            document.getElementById('customScript').value = '';
            addLog('Strategy cleared', 'info');
        }

        function evaluateMultiTimeframeStrategy(timeframeData, strategy) {
            if (!strategy) return 'N/A';

            try {
                # Extract data from all timeframes
                var data_1m = timeframeData['1m'] || {};
                var data_5m = timeframeData['5m'] || {};
                var data_15m = timeframeData['15m'] || {};
                var data_4h = timeframeData['4h'] || {};

                # Convert ThinkOrSwim multi-timeframe syntax to JavaScript
                var jsCode = strategy
                    # Handle aggregationPeriod references
                    .replace(/RSI\(length\s*=\s*(\d+),\s*aggregationPeriod\s*=\s*AggregationPeriod\.MIN\)/g, function(match, length) {
                        return data_1m.rsi || 50;
                    })
                    .replace(/RSI\(length\s*=\s*(\d+),\s*aggregationPeriod\s*=\s*AggregationPeriod\.FIVE_MIN\)/g, function(match, length) {
                        return data_5m.rsi || 50;
                    })
                    .replace(/RSI\(length\s*=\s*(\d+),\s*aggregationPeriod\s*=\s*AggregationPeriod\.FIFTEEN_MIN\)/g, function(match, length) {
                        return data_15m.rsi || 50;
                    })
                    .replace(/RSI\(length\s*=\s*(\d+),\s*aggregationPeriod\s*=\s*AggregationPeriod\.FOUR_HOURS\)/g, function(match, length) {
                        return data_4h.rsi || 50;
                    })

                    # Handle MACD with timeframes
                    .replace(/MACD\(aggregationPeriod\s*=\s*AggregationPeriod\.MIN\)/g, function() {
                        var macd = data_1m.macd || {macd: 0, signal: 0};
                        return '{Value: ' + macd.macd + ', Avg: ' + macd.signal + '}';
                    })
                    .replace(/MACD\(aggregationPeriod\s*=\s*AggregationPeriod\.FIFTEEN_MIN\)/g, function() {
                        var macd = data_15m.macd || {macd: 0, signal: 0};
                        return '{Value: ' + macd.macd + ', Avg: ' + macd.signal + '}';
                    })

                    # Handle Average (SMA) with timeframes
                    .replace(/Average\(close,\s*(\d+),\s*aggregationPeriod\s*=\s*AggregationPeriod\.FOUR_HOURS\)/g, function(match, period) {
                        return data_4h.sma20 || data_4h.currentPrice || 100;
                    })

                    # Handle def statements
                    .replace(/def\s+(\w+)\s*=/g, 'var $1 =')

                    # Handle basic price references
                    .replace(/\bclose\b/g, data_1m.currentPrice || 100)
                    .replace(/\bhigh\b/g, data_1m.high || data_1m.currentPrice || 100)
                    .replace(/\blow\b/g, data_1m.low || data_1m.currentPrice || 100)
                    .replace(/\bvolume\b/g, data_1m.volume || 0)

                    # Handle logical operators
                    .replace(/\band\b/g, '&&')
                    .replace(/\bor\b/g, '||')
                    .replace(/\bnot\b/g, '!')

                    # Remove comments (only # comments as per your note)
                    .replace(/#.*$/gm, '')
                    .replace(/\s+/g, ' ')
                    .trim();

                # Look for BUY_CONDITION and SELL_CONDITION
                var lines = jsCode.split(';');
                var buyCondition = false;
                var sellCondition = false;

                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i].trim();
                    if (line.indexOf('BUY_CONDITION') !== -1) {
                        # Extract and evaluate buy condition
                        var condition = line.split('=')[1];
                        if (condition) {
                            try {
                                buyCondition = eval(condition.trim());
                            } catch (e) {
                                buyCondition = evaluateConditionPatterns(condition, timeframeData);
                            }
                        }
                    }
                    if (line.indexOf('SELL_CONDITION') !== -1) {
                        # Extract and evaluate sell condition
                        var condition = line.split('=')[1];
                        if (condition) {
                            try {
                                sellCondition = eval(condition.trim());
                            } catch (e) {
                                sellCondition = evaluateConditionPatterns(condition, timeframeData);
                            }
                        }
                    }
                }

                # Return signal based on conditions
                if (buyCondition) return 'BUY';
                if (sellCondition) return 'SELL';
                return 'HOLD';

            } catch (error) {
                console.log('Multi-timeframe strategy evaluation error:', error);
                return 'ERROR';
            }
        }

        function evaluateConditionPatterns(condition, timeframeData) {
            # Pattern matching for complex multi-timeframe conditions
            var data_1m = timeframeData['1m'] || {};
            var data_5m = timeframeData['5m'] || {};
            var data_15m = timeframeData['15m'] || {};
            var data_4h = timeframeData['4h'] || {};

            # Check for trend alignment
            if (condition.indexOf('trend_bullish') !== -1) {
                var currentPrice = data_1m.currentPrice || 100;
                var sma20_4h = data_4h.sma20 || currentPrice;
                return currentPrice > sma20_4h;
            }

            # Check for momentum conditions
            if (condition.indexOf('momentum') !== -1) {
                var macd_15m = data_15m.macd || {macd: 0, signal: 0};
                return macd_15m.macd > macd_15m.signal;
            }

            # Check for oversold conditions
            if (condition.indexOf('oversold') !== -1) {
                return (data_5m.rsi || 50) < 30;
            }

            # Check for entry conditions
            if (condition.indexOf('entry') !== -1) {
                return (data_1m.rsi || 50) < 25;
            }

            return false;
        }

        function checkTradingSignals() {
            if (!isAutoTrading || !currentTicker || !customStrategy) return;

            try {
                # Use multi-timeframe evaluation
                var signal = evaluateMultiTimeframeStrategy(multiTimeframeData, customStrategy);

                if (signal === 'BUY' || signal === 'SELL') {
                    addLog('Multi-timeframe auto signal: ' + signal + ' for ' + currentTicker, 'info');

                    var hasPosition = false;
                    for (var i = 0; i < activeTrades.length; i++) {
                        if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                            hasPosition = true;
                            break;
                        }
                    }

                    if (signal === 'BUY' && !hasPosition) {
                        addLog('Multi-timeframe BUY signal confirmed across timeframes', 'success');
                        executeTrade('buy');
                    } else if (signal === 'SELL' && hasPosition) {
                        addLog('Multi-timeframe SELL signal confirmed across timeframes', 'warning');
                        executeTrade('sell');
                    }
                }
            } catch (error) {
                addLog('Multi-timeframe signal check failed: ' + error.message, 'error');
            }
        }
                     + primaryData.currentPrice.toFixed(2);
            document.getElementById('volume').textContent = (primaryData.volume || 0).toLocaleString();

            # Update multi-timeframe RSI indicators
            if (multiTimeframeData['1m']) {
                document.getElementById('rsi_1m').textContent = (multiTimeframeData['1m'].rsi || 0).toFixed(2);
            }
            if (multiTimeframeData['5m']) {
                document.getElementById('rsi_5m').textContent = (multiTimeframeData['5m'].rsi || 0).toFixed(2);
            }
            if (multiTimeframeData['15m']) {
                document.getElementById('rsi_15m').textContent = (multiTimeframeData['15m'].rsi || 0).toFixed(2);
            }

            # Update multi-timeframe MACD indicators
            if (multiTimeframeData['1m'] && multiTimeframeData['1m'].macd) {
                document.getElementById('macd_1m').textContent = multiTimeframeData['1m'].macd.macd.toFixed(4);
            }
            if (multiTimeframeData['15m'] && multiTimeframeData['15m'].macd) {
                document.getElementById('macd_15m').textContent = multiTimeframeData['15m'].macd.macd.toFixed(4);
            }

            # Update 4-hour SMA
            if (multiTimeframeData['4h']) {
                document.getElementById('sma20_4h').textContent = '

        function updateChart() {
            if (priceData.length === 0) return;

            var canvas = document.getElementById('priceChart');
            var ctx = canvas.getContext('2d');

            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (priceData.length < 2) return;

            var prices = priceData.map(function(d) { return d.price; });
            var minPrice = Math.min.apply(Math, prices);
            var maxPrice = Math.max.apply(Math, prices);
            var priceRange = maxPrice - minPrice || 1;

            ctx.strokeStyle = '#4facfe';
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (var i = 0; i < priceData.length; i++) {
                var x = (i / (priceData.length - 1)) * canvas.width;
                var y = canvas.height - ((priceData[i].price - minPrice) / priceRange) * canvas.height;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.stroke();
        }

        function executeTrade(action) {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!isConnected) {
                alert('API connection lost');
                return;
            }

            var quantity = parseInt(document.getElementById('quantity').value);
            var currentPrice = indicators.currentPrice || 100;

            var orderData = {
                symbol: currentTicker,
                action: action.toUpperCase(),
                quantity: quantity,
                orderType: 'MARKET',
                timeInForce: 'DAY',
                price: currentPrice
            };

            fetch(API_BASE_URL + '/api/orders', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(orderData)
            })
            .then(function(response) {
                return response.json();
            })
            .then(function(result) {
                if (result.success) {
                    addLog(action.toUpperCase() + ' order executed: ' + quantity + ' shares at $' + currentPrice.toFixed(2), 'success');

                    var trade = {
                        id: Date.now(),
                        symbol: currentTicker,
                        action: action.toUpperCase(),
                        quantity: quantity,
                        entryPrice: currentPrice,
                        timestamp: new Date(),
                        status: 'OPEN'
                    };

                    if (action.toUpperCase() === 'BUY') {
                        activeTrades.push(trade);
                    } else {
                        var existingTrade = null;
                        for (var i = 0; i < activeTrades.length; i++) {
                            if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                                existingTrade = activeTrades[i];
                                break;
                            }
                        }

                        if (existingTrade) {
                            existingTrade.status = 'CLOSED';
                            existingTrade.exitPrice = currentPrice;
                            var profit = (currentPrice - existingTrade.entryPrice) * existingTrade.quantity;
                            realizedPnL += profit;
                            addLog('Position closed: ' + (profit > 0 ? '+' : '') + '$' + profit.toFixed(2), profit > 0 ? 'success' : 'error');
                        }
                    }

                    updateActiveTradesDisplay();
                    updatePnLDisplay();
                    alert(action.toUpperCase() + ' order submitted successfully!');
                } else {
                    throw new Error(result.error);
                }
            })
            .catch(function(error) {
                addLog('Trade failed: ' + error.message, 'error');
                alert('Trade failed: ' + error.message);
            });
        }

        function cancelAllOrders() {
            addLog('All orders cancelled', 'warning');
            alert('All orders cancelled');
        }

        function setStopLoss() {
            var stopLossPercent = document.getElementById('stopLossPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var stopPrice = currentPrice * (1 - stopLossPercent / 100);

            addLog('Stop loss set at $' + stopPrice.toFixed(2), 'warning');
            alert('Stop loss set at $' + stopPrice.toFixed(2));
        }

        function setProfitTarget() {
            var profitTargetPercent = document.getElementById('profitTargetPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var targetPrice = currentPrice * (1 + profitTargetPercent / 100);

            addLog('Profit target set at $' + targetPrice.toFixed(2), 'success');
            alert('Profit target set at $' + targetPrice.toFixed(2));
        }

        function toggleAutomation() {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            isAutoTrading = !isAutoTrading;
            var toggleBtn = document.getElementById('toggleAuto');
            var statusIndicator = document.getElementById('autoStatus');
            var statusText = document.getElementById('autoStatusText');

            if (isAutoTrading) {
                toggleBtn.textContent = 'Stop Auto Trading';
                toggleBtn.className = 'btn btn-danger';
                statusIndicator.className = 'status-indicator status-active';
                statusText.textContent = 'Active';
                addLog('Auto trading started', 'success');

                autoTradingInterval = setInterval(function() {
                    checkTradingSignals();
                }, 30000);

            } else {
                toggleBtn.textContent = 'Start Auto Trading';
                toggleBtn.className = 'btn btn-primary';
                statusIndicator.className = 'status-indicator status-inactive';
                statusText.textContent = 'Inactive';
                addLog('Auto trading stopped', 'warning');

                if (autoTradingInterval) {
                    clearInterval(autoTradingInterval);
                    autoTradingInterval = null;
                }
            }
        }

        function loadStrategy() {
            var strategyCode = document.getElementById('customScript').value.trim();
            if (!strategyCode) {
                alert('Please enter a strategy first');
                return;
            }

            customStrategy = strategyCode;
            addLog('Strategy loaded', 'success');
            alert('Strategy loaded successfully!');
        }

        function testStrategy() {
            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            if (!indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            try {
                var result = evaluateCustomStrategy(indicators);
                addLog('Strategy test result: ' + result, 'info');
                alert('Strategy test result: ' + result);
            } catch (error) {
                addLog('Strategy test failed', 'error');
                alert('Strategy test failed');
            }
        }

        function clearStrategy() {
            customStrategy = '';
            document.getElementById('customScript').value = '';
            addLog('Strategy cleared', 'info');
        }

        function evaluateCustomStrategy(data) {
            if (!customStrategy) return 'N/A';

            try {
                var rsi = data.rsi || 50;
                var macd = data.macd ? data.macd.macd : 0;
                var price = data.currentPrice || 100;

                if (customStrategy.indexOf('rsi < 30') !== -1 && rsi < 30) {
                    return 'BUY';
                }
                if (customStrategy.indexOf('rsi > 70') !== -1 && rsi > 70) {
                    return 'SELL';
                }

                return 'HOLD';
            } catch (error) {
                throw new Error('Strategy evaluation failed');
            }
        }

        function checkTradingSignals() {
            if (!isAutoTrading || !currentTicker || !customStrategy) return;

            try {
                var signal = evaluateCustomStrategy(indicators);

                if (signal === 'BUY' || signal === 'SELL') {
                    addLog('Auto signal: ' + signal, 'info');

                    var hasPosition = false;
                    for (var i = 0; i < activeTrades.length; i++) {
                        if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                            hasPosition = true;
                            break;
                        }
                    }
                     + (multiTimeframeData['4h'].sma20 || 0).toFixed(2);
            }

            # Update signal display
            var signal = primaryData.signal || 'HOLD';
            var signalDisplay = document.getElementById('signalDisplay');
            var signalText = document.getElementById('signalText');

            signalText.textContent = signal;
            signalDisplay.className = 'signal-display signal-' + signal.toLowerCase();

            # Evaluate custom multi-timeframe strategy
            if (customStrategy) {
                try {
                    var customResult = evaluateMultiTimeframeStrategy(multiTimeframeData, customStrategy);
                    document.getElementById('customIndicatorValue').textContent = customResult;
                } catch (error) {
                    document.getElementById('customIndicatorValue').textContent = 'Error';
                    addLog('Multi-timeframe strategy error: ' + error.message, 'error');
                }
            }
        }

        function updateChart() {
            if (priceData.length === 0) return;

            var canvas = document.getElementById('priceChart');
            var ctx = canvas.getContext('2d');

            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (priceData.length < 2) return;

            var prices = priceData.map(function(d) { return d.price; });
            var minPrice = Math.min.apply(Math, prices);
            var maxPrice = Math.max.apply(Math, prices);
            var priceRange = maxPrice - minPrice || 1;

            ctx.strokeStyle = '#4facfe';
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (var i = 0; i < priceData.length; i++) {
                var x = (i / (priceData.length - 1)) * canvas.width;
                var y = canvas.height - ((priceData[i].price - minPrice) / priceRange) * canvas.height;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.stroke();
        }

        function executeTrade(action) {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!isConnected) {
                alert('API connection lost');
                return;
            }

            var quantity = parseInt(document.getElementById('quantity').value);
            var currentPrice = indicators.currentPrice || 100;

            var orderData = {
                symbol: currentTicker,
                action: action.toUpperCase(),
                quantity: quantity,
                orderType: 'MARKET',
                timeInForce: 'DAY',
                price: currentPrice
            };

            fetch(API_BASE_URL + '/api/orders', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(orderData)
            })
            .then(function(response) {
                return response.json();
            })
            .then(function(result) {
                if (result.success) {
                    addLog(action.toUpperCase() + ' order executed: ' + quantity + ' shares at $' + currentPrice.toFixed(2), 'success');

                    var trade = {
                        id: Date.now(),
                        symbol: currentTicker,
                        action: action.toUpperCase(),
                        quantity: quantity,
                        entryPrice: currentPrice,
                        timestamp: new Date(),
                        status: 'OPEN'
                    };

                    if (action.toUpperCase() === 'BUY') {
                        activeTrades.push(trade);
                    } else {
                        var existingTrade = null;
                        for (var i = 0; i < activeTrades.length; i++) {
                            if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                                existingTrade = activeTrades[i];
                                break;
                            }
                        }

                        if (existingTrade) {
                            existingTrade.status = 'CLOSED';
                            existingTrade.exitPrice = currentPrice;
                            var profit = (currentPrice - existingTrade.entryPrice) * existingTrade.quantity;
                            realizedPnL += profit;
                            addLog('Position closed: ' + (profit > 0 ? '+' : '') + '$' + profit.toFixed(2), profit > 0 ? 'success' : 'error');
                        }
                    }

                    updateActiveTradesDisplay();
                    updatePnLDisplay();
                    alert(action.toUpperCase() + ' order submitted successfully!');
                } else {
                    throw new Error(result.error);
                }
            })
            .catch(function(error) {
                addLog('Trade failed: ' + error.message, 'error');
                alert('Trade failed: ' + error.message);
            });
        }

        function cancelAllOrders() {
            addLog('All orders cancelled', 'warning');
            alert('All orders cancelled');
        }

        function setStopLoss() {
            var stopLossPercent = document.getElementById('stopLossPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var stopPrice = currentPrice * (1 - stopLossPercent / 100);

            addLog('Stop loss set at $' + stopPrice.toFixed(2), 'warning');
            alert('Stop loss set at $' + stopPrice.toFixed(2));
        }

        function setProfitTarget() {
            var profitTargetPercent = document.getElementById('profitTargetPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var targetPrice = currentPrice * (1 + profitTargetPercent / 100);

            addLog('Profit target set at $' + targetPrice.toFixed(2), 'success');
            alert('Profit target set at $' + targetPrice.toFixed(2));
        }

        function toggleAutomation() {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            isAutoTrading = !isAutoTrading;
            var toggleBtn = document.getElementById('toggleAuto');
            var statusIndicator = document.getElementById('autoStatus');
            var statusText = document.getElementById('autoStatusText');

            if (isAutoTrading) {
                toggleBtn.textContent = 'Stop Auto Trading';
                toggleBtn.className = 'btn btn-danger';
                statusIndicator.className = 'status-indicator status-active';
                statusText.textContent = 'Active';
                addLog('Auto trading started', 'success');

                autoTradingInterval = setInterval(function() {
                    checkTradingSignals();
                }, 30000);

            } else {
                toggleBtn.textContent = 'Start Auto Trading';
                toggleBtn.className = 'btn btn-primary';
                statusIndicator.className = 'status-indicator status-inactive';
                statusText.textContent = 'Inactive';
                addLog('Auto trading stopped', 'warning');

                if (autoTradingInterval) {
                    clearInterval(autoTradingInterval);
                    autoTradingInterval = null;
                }
            }
        }

        function loadStrategy() {
            var strategyCode = document.getElementById('customScript').value.trim();
            if (!strategyCode) {
                alert('Please enter a strategy first');
                return;
            }

            customStrategy = strategyCode;
            addLog('Strategy loaded', 'success');
            alert('Strategy loaded successfully!');
        }

        function testStrategy() {
            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            if (!indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            try {
                var result = evaluateCustomStrategy(indicators);
                addLog('Strategy test result: ' + result, 'info');
                alert('Strategy test result: ' + result);
            } catch (error) {
                addLog('Strategy test failed', 'error');
                alert('Strategy test failed');
            }
        }

        function clearStrategy() {
            customStrategy = '';
            document.getElementById('customScript').value = '';
            addLog('Strategy cleared', 'info');
        }

        function evaluateCustomStrategy(data) {
            if (!customStrategy) return 'N/A';

            try {
                var rsi = data.rsi || 50;
                var macd = data.macd ? data.macd.macd : 0;
                var price = data.currentPrice || 100;

                if (customStrategy.indexOf('rsi < 30') !== -1 && rsi < 30) {
                    return 'BUY';
                }
                if (customStrategy.indexOf('rsi > 70') !== -1 && rsi > 70) {
                    return 'SELL';
                }

                return 'HOLD';
            } catch (error) {
                throw new Error('Strategy evaluation failed');
            }
        }

        function checkTradingSignals() {
            if (!isAutoTrading || !currentTicker || !customStrategy) return;

            try {
                var signal = evaluateCustomStrategy(indicators);

                if (signal === 'BUY' || signal === 'SELL') {
                    addLog('Auto signal: ' + signal, 'info');

                    var hasPosition = false;
                    for (var i = 0; i < activeTrades.length; i++) {
                        if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                            hasPosition = true;
                            break;
                        }
                    }
                     + realizedPnL.toFixed(2), 'info');
        }

        function executeSellOrder(symbol, quantity) {
            # Execute the actual sell order
            var orderData = {
                symbol: symbol,
                action: 'SELL',
                quantity: quantity,
                orderType: 'MARKET',
                timeInForce: 'DAY'
            };

            fetch(API_BASE_URL + '/api/orders', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(orderData)
            })
            .then(function(response) {
                return response.json();
            })
            .then(function(result) {
                addLog('Emergency sell executed: ' + symbol, 'success');
            })
            .catch(function(error) {
                addLog('Emergency sell failed for ' + symbol + ': ' + error.message, 'error');
            });
        }

        function emergencyStop() {
            emergencyStopActive = !emergencyStopActive;
            var emergencyBtn = event.target;

            if (emergencyStopActive) {
                # FULL EMERGENCY STOP
                emergencyBtn.textContent = 'Resume All';
                emergencyBtn.className = 'btn btn-danger';

                # Stop auto trading
                if (isAutoTrading) {
                    toggleAutomation();
                }

                # Activate hold mode
                if (!isHoldMode) {
                    toggleHoldMode();
                }

                # Close all positions
                closeAllPositions();

                # Cancel all pending orders
                cancelAllOrders();

                # Update status indicators
                var holdStatus = document.getElementById('holdStatus');
                holdStatus.className = 'status-indicator status-emergency';

                addLog('EMERGENCY STOP ACTIVATED - All trading halted, positions closed', 'error');
                alert('EMERGENCY STOP ACTIVATED!\\n\\n Auto trading stopped\\n All positions closed\\n All orders cancelled\\n System in HOLD mode');

            } else {
                # RESUME FROM EMERGENCY
                emergencyBtn.textContent = 'Emergency Stop';
                emergencyBtn.className = 'btn btn-secondary';

                # Deactivate hold mode
                if (isHoldMode) {
                    toggleHoldMode();
                }

                addLog('Emergency stop deactivated - System ready for trading', 'success');
                alert('Emergency stop deactivated.\\nSystem is ready for trading.\\nYou can now restart auto trading if desired.');
            }
        }

        function checkTradingPermissions() {
            # Check if trading is allowed based on current modes
            if (emergencyStopActive) {
                addLog('Trade blocked: Emergency stop is active', 'error');
                return false;
            }

            if (isHoldMode) {
                addLog('Trade blocked: HOLD mode is active', 'warning');
                return false;
            }

            return true;
        }
        @media (max-width: 1200px) {
            .main-grid { grid-template-columns: 1fr; }
            .watchlist-panel {
                order: 3;
                max-height: 180px;
            }
            .scanner-panel {
                order: 4;
                max-height: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Fynda Auto Trading BOT</h1>
            <div class="connection-status" id="connectionStatus">Connecting...</div>
        </div>

        <div class="main-grid">
            <div class="left-panel">
                <div class="section-title">Trading Controls</div>

                <div class="form-group">
                    <label for="ticker">Select Stock:</label>
                    <select id="ticker" required>
                        <option value="">Loading stocks...</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="customTicker">Or Enter Custom Stock Symbol:</label>
                    <input type="text" id="customTicker" placeholder="e.g., PLTR, COIN, GME" style="text-transform: uppercase;">
                </div>

                <div class="form-group">
                    <label for="quantity">Quantity:</label>
                    <input type="number" id="quantity" min="1" max="10000" value="100" required>
                </div>

                <div class="button-grid">
                    <button class="btn btn-buy" onclick="executeTrade('buy')">Buy</button>
                    <button class="btn btn-sell" onclick="executeTrade('sell')">Sell</button>
                </div>

                <div class="button-row">
                    <button class="btn btn-cancel" onclick="cancelAllOrders()">Cancel All</button>
                    <button class="btn btn-secondary" onclick="setStopLoss()">Stop Loss</button>
                    <button class="btn btn-success" onclick="setProfitTarget()">Profit Target</button>
                </div>

                <div class="button-row" style="margin-top: 10px;">
                    <button class="btn btn-primary" id="holdBtn" onclick="toggleHoldMode()">Force HOLD</button>
                    <button class="btn btn-danger" onclick="closeAllPositions()">Close All</button>
                    <button class="btn btn-secondary" onclick="emergencyStop()">Emergency Stop</button>
                </div>

                <div class="automation-panel">
                    <div class="automation-status">
                        <span>Auto Trading:</span>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div class="status-indicator status-inactive" id="autoStatus"></div>
                            <span id="autoStatusText">Inactive</span>
                        </div>
                    </div>
                    <div class="automation-status" style="margin-top: 8px;">
                        <span>Position Mode:</span>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div class="status-indicator status-inactive" id="holdStatus"></div>
                            <span id="holdStatusText">Trading</span>
                        </div>
                    </div>
                    <button class="btn btn-primary" id="toggleAuto" onclick="toggleAutomation()" style="width: 100%;">
                        Start Auto Trading
                    </button>
                </div>

                <div class="pnl-display">
                    <div class="indicator-label">Today's P&L</div>
                    <div class="pnl-value" id="totalPnL">$0.00</div>
                    <div style="display: flex; justify-content: space-between; font-size: 12px; margin-top: 8px;">
                        <span>Realized: <span id="realizedPnL">$0.00</span></span>
                        <span>Unrealized: <span id="unrealizedPnL">$0.00</span></span>
                    </div>
                </div>

                <div class="trades-panel">
                    <div class="indicator-label" style="margin-bottom: 10px;">Active Trades</div>
                    <div id="activeTradesList">No active trades</div>
                </div>
            </div>

            <div class="center-panel">
                <div class="section-title">Market Analysis</div>

                <div class="chart-controls">
                    <button class="chart-btn active" data-timeframe="1m">1M</button>
                    <button class="chart-btn" data-timeframe="5m">5M</button>
                    <button class="chart-btn" data-timeframe="15m">15M</button>
                    <button class="chart-btn" data-timeframe="1h">1H</button>
                </div>

                <div class="chart-container" id="chartContainer">
                    <canvas id="priceChart" style="width: 100%; height: 100%;"></canvas>
                </div>

                <div class="indicators-grid">
                    <div class="indicator-card">
                        <div class="indicator-value" id="currentPrice">$0.00</div>
                        <div class="indicator-label">Price (1m)</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="rsi_1m">0.00</div>
                        <div class="indicator-label">RSI (1m)</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="rsi_5m">0.00</div>
                        <div class="indicator-label">RSI (5m)</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="rsi_15m">0.00</div>
                        <div class="indicator-label">RSI (15m)</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="macd_1m">0.00</div>
                        <div class="indicator-label">MACD (1m)</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="macd_15m">0.00</div>
                        <div class="indicator-label">MACD (15m)</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="sma20_4h">0.00</div>
                        <div class="indicator-label">SMA20 (4h)</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="volume">0</div>
                        <div class="indicator-label">Volume</div>
                    </div>
                    <div class="indicator-card">
                        <div class="indicator-value" id="customIndicatorValue">N/A</div>
                        <div class="indicator-label">Strategy Signal</div>
                    </div>
                </div>

                <div class="signal-display" id="signalDisplay">
                    <div id="signalText">HOLD</div>
                </div>
            </div>

            <div class="right-panel">
                <div class="section-title">Custom Strategy</div>

                <div class="form-group">
                    <label for="customScript">ThinkOrSwim Multi-Timeframe Strategy:</label>
                    <textarea id="customScript" class="custom-script-area" placeholder="# ThinkOrSwim Multi-Timeframe Strategy Code
# This bot supports 1m, 5m, 15m, and 4h timeframe analysis
# Use aggregationPeriod to reference different timeframes
#
# Example Multi-Timeframe Strategy:
# def rsi_1m = RSI(length = 14, aggregationPeriod = AggregationPeriod.MIN);
# def rsi_5m = RSI(length = 14, aggregationPeriod = AggregationPeriod.FIVE_MIN);
# def rsi_15m = RSI(length = 14, aggregationPeriod = AggregationPeriod.FIFTEEN_MIN);
# def rsi_4h = RSI(length = 14, aggregationPeriod = AggregationPeriod.FOUR_HOURS);
#
# def macd_15m = MACD(aggregationPeriod = AggregationPeriod.FIFTEEN_MIN);
# def sma20_4h = Average(close, 20, aggregationPeriod = AggregationPeriod.FOUR_HOURS);
#
# # Multi-timeframe conditions
# def trend_bullish_4h = close > sma20_4h;
# def momentum_15m = macd_15m.Value > macd_15m.Avg;
# def oversold_5m = rsi_5m < 30;
# def entry_1m = rsi_1m < 25;
#
# # Combined entry signal
# BUY_CONDITION = trend_bullish_4h and momentum_15m and oversold_5m and entry_1m;
# SELL_CONDITION = rsi_1m > 75 or rsi_5m > 80;"></textarea>
                </div>

                <div class="button-row">
                    <button class="btn btn-primary" onclick="loadStrategy()">Load</button>
                    <button class="btn btn-secondary" onclick="testStrategy()">Test</button>
                    <button class="btn btn-danger" onclick="clearStrategy()">Clear</button>
                </div>

                <div class="form-group" style="margin-top: 15px;">
                    <label for="stopLossPercent">Stop Loss %:</label>
                    <input type="number" id="stopLossPercent" min="0.1" max="10" step="0.1" value="2">

                    <label for="profitTargetPercent">Profit Target %:</label>
                    <input type="number" id="profitTargetPercent" min="0.1" max="20" step="0.1" value="4">
                </div>

                <button class="btn btn-primary" onclick="showLogs()" style="width: 100%; margin-top: 15px;">
                    View Logs
                </button>

                <div class="logs-panel" id="logsPanel">
                    <div id="logEntries"></div>
                </div>
            </div>

            <div class="watchlist-panel">
                <div class="section-title">Live Watchlist</div>

                <div class="watchlist-controls">
                    <button class="watchlist-btn" onclick="refreshWatchlist()">Refresh</button>
                    <button class="watchlist-btn" onclick="editWatchlist()">Edit</button>
                </div>

                <div class="watchlist-container" id="watchlistContainer">
                    <div class="watchlist-item">
                        <div class="watchlist-ticker">Loading...</div>
                        <div class="watchlist-price">$0.00</div>
                    </div>
                </div>
            </div>

            <div class="scanner-panel">
                <div class="section-title">Market Scanner</div>

                <div class="scanner-controls">
                    <textarea id="scannerCode" class="scanner-code-area" placeholder="# Enter your ThinkOrSwim scanning code:
# Example 1 - RSI Oversold:
# def rsi = RSI(length = 14);
# def volume_avg = Average(volume, 20);
# rsi < 30 and volume > volume_avg * 1.5;
#
# Example 2 - MACD Bullish:
# def macd = MACD();
# def price_sma = Average(close, 20);
# macd.Value > macd.Avg and close > price_sma;
#
# Example 3 - Breakout Pattern:
# def high20 = Highest(high, 20);
# def vol_avg = Average(volume, 10);
# close > high20[1] and volume > vol_avg * 2;"></textarea>

                    <button class="scanner-btn" id="scanBtn" onclick="startScanning()">Start Scan</button>
                    <button class="scanner-btn" onclick="stopScanning()">Stop Scan</button>
                </div>

                <div class="scan-status" id="scanStatus">
                    Ready to scan. Enter criteria above.
                </div>

                <div class="scanner-container" id="scannerContainer">
                    <div class="scanner-item">
                        <div class="scanner-ticker">No scans yet</div>
                        <div style="font-size: 12px; opacity: 0.8;">Enter criteria and click Start Scan</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        var API_BASE_URL = window.location.origin;
        var currentTicker = '';
        var isConnected = false;
        var isAutoTrading = false;
        var isHoldMode = false;
        var emergencyStopActive = false;
        var currentTimeframe = '1m';
        var customStrategy = '';
        var priceData = {};
        var multiTimeframeData = {};
        var indicators = {};
        var activeTrades = [];
        var totalPnL = 0;
        var realizedPnL = 0;
        var unrealizedPnL = 0;
        var autoTradingInterval = null;

        var watchlistStocks = ['AAPL', 'TSLA', 'GOOGL', 'MSFT', 'NVDA', 'META', 'AMZN', 'SPY', 'QQQ', 'AMD'];
        var watchlistData = {};

        var isScanning = false;
        var scanningInterval = null;
        var scannerCode = '';
        var scannedStocks = [];
        var allStocks = [
            'AAPL', 'TSLA', 'GOOGL', 'MSFT', 'NVDA', 'META', 'AMZN', 'NFLX', 'AMD', 'CRM',
            'SPY', 'QQQ', 'IWM', 'DIA', 'ARKK', 'TQQQ', 'SQQQ', 'VTI', 'VOO', 'VEA',
            'PLTR', 'COIN', 'RBLX', 'HOOD', 'SOFI', 'GME', 'AMC', 'BB', 'NOK', 'SNDL',
            'F', 'GE', 'BAC', 'JPM', 'WFC', 'V', 'MA', 'KO', 'PEP', 'DIS', 'NKE',
            'BABA', 'TSM', 'ASML', 'INTC', 'CSCO', 'ORCL', 'ADBE', 'PYPL', 'AVGO', 'TXN'
        ];
        var scannerResults = {};

        var POPULAR_STOCKS = [
            'AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA', 'META', 'NVDA', 'NFLX', 'AMD', 'CRM',
            'SPY', 'QQQ', 'IWM', 'DIA', 'ARKK', 'TQQQ', 'SQQQ', 'SPXL', 'UPRO', 'TMF'
        ];

        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
        });

        function initializeApp() {
            loadStockList();
            setupEventListeners();
            checkAPIConnection();
            startRealTimeUpdates();
            initializeWatchlist();
            addLog('System initialized', 'success');
        }

        function loadStockList() {
            var tickerSelect = document.getElementById('ticker');
            tickerSelect.innerHTML = '<option value="">Choose a stock...</option>';

            for (var i = 0; i < POPULAR_STOCKS.length; i++) {
                var option = document.createElement('option');
                option.value = POPULAR_STOCKS[i];
                option.textContent = POPULAR_STOCKS[i];
                tickerSelect.appendChild(option);
            }

            addLog('Stock list loaded', 'info');
        }

        function setupEventListeners() {
            document.getElementById('ticker').addEventListener('change', function() {
                if (this.value) {
                    document.getElementById('customTicker').value = '';
                    currentTicker = this.value;
                    addLog('Selected ticker: ' + currentTicker, 'info');
                    updateMarketData(currentTicker);
                }
            });

            document.getElementById('customTicker').addEventListener('input', function() {
                var customValue = this.value.toUpperCase().trim();
                if (customValue) {
                    document.getElementById('ticker').value = '';
                    currentTicker = customValue;
                    addLog('Custom ticker entered: ' + currentTicker, 'info');

                    if (customValue.length >= 1) {
                        updateMarketData(currentTicker);
                    }
                }
            });

            var chartBtns = document.querySelectorAll('.chart-btn');
            for (var i = 0; i < chartBtns.length; i++) {
                chartBtns[i].addEventListener('click', function() {
                    var allBtns = document.querySelectorAll('.chart-btn');
                    for (var j = 0; j < allBtns.length; j++) {
                        allBtns[j].classList.remove('active');
                    }
                    this.classList.add('active');
                    currentTimeframe = this.dataset.timeframe;
                    addLog('Changed timeframe to: ' + currentTimeframe, 'info');
                });
            }
        }

        function checkAPIConnection() {
            fetch(API_BASE_URL + '/api/health')
                .then(function(response) {
                    if (response.ok) {
                        isConnected = true;
                        updateConnectionStatus('Online');
                        addLog('API connected', 'success');
                    } else {
                        throw new Error('API check failed');
                    }
                })
                .catch(function(error) {
                    isConnected = false;
                    updateConnectionStatus('Offline');
                    addLog('API connection failed', 'error');
                });
        }

        function updateConnectionStatus(status) {
            var statusElement = document.getElementById('connectionStatus');
            if (status === 'Online') {
                statusElement.textContent = 'Online';
                statusElement.className = 'connection-status connection-online';
            } else {
                statusElement.textContent = 'Offline';
                statusElement.className = 'connection-status connection-offline';
            }
        }

        function startRealTimeUpdates() {
            setInterval(function() {
                if (currentTicker && isConnected) {
                    updateMarketData(currentTicker);
                }
            }, 5000);

            setInterval(function() {
                if (activeTrades.length > 0) {
                    updatePnLDisplay();
                }
            }, 10000);

            setInterval(function() {
                if (isAutoTrading && currentTicker && customStrategy) {
                    checkTradingSignals();
                }
            }, 30000);

            setInterval(function() {
                if (isConnected) {
                    updateWatchlist();
                }
            }, 3000);

            setInterval(function() {
                if (isScanning && isConnected) {
                    runMarketScan();
                }
            }, 10000);
        }

        function updateMarketData(symbol) {
            if (!isConnected) return;

            # Fetch data for all required timeframes
            var timeframes = ['1m', '5m', '15m', '4h'];
            var dataPromises = [];

            for (var i = 0; i < timeframes.length; i++) {
                var tf = timeframes[i];
                dataPromises.push(
                    fetch(API_BASE_URL + '/api/market-data/' + symbol + '?timeframe=' + tf)
                        .then(function(response) { return response.json(); })
                        .catch(function(error) {
                            # Fallback to simulated multi-timeframe data
                            return generateSimulatedTimeframeData(symbol, tf);
                        })
                );
            }

            Promise.all(dataPromises)
                .then(function(results) {
                    # Organize data by timeframe
                    multiTimeframeData = {};
                    for (var i = 0; i < timeframes.length; i++) {
                        multiTimeframeData[timeframes[i]] = results[i];
                    }

                    # Use 1m data as primary for display
                    var primaryData = multiTimeframeData['1m'];
                    if (primaryData && primaryData.currentPrice) {
                        updateMultiTimeframeIndicators(primaryData);

                        # Store price data for charting
                        if (!priceData[symbol]) priceData[symbol] = [];
                        priceData[symbol].push({
                            time: new Date(),
                            price: primaryData.currentPrice,
                            volume: primaryData.volume
                        });

                        # Keep only last 100 data points per symbol
                        if (priceData[symbol].length > 100) {
                            priceData[symbol] = priceData[symbol].slice(-100);
                        }

                        updateChart();
                    }
                })
                .catch(function(error) {
                    addLog('Multi-timeframe data error: ' + error.message, 'error');
                });
        }

        function generateSimulatedTimeframeData(symbol, timeframe) {
            # Generate simulated multi-timeframe data
            var basePrice = 150 + Math.random() * 50;
            var volatility = timeframe === '1m' ? 1 : timeframe === '5m' ? 2 : timeframe === '15m' ? 3 : 5;

            return {
                symbol: symbol,
                timeframe: timeframe,
                currentPrice: basePrice + (Math.random() - 0.5) * volatility,
                rsi: 30 + Math.random() * 40,
                macd: {
                    macd: (Math.random() - 0.5) * 2,
                    signal: (Math.random() - 0.5) * 1.5,
                    histogram: (Math.random() - 0.5) * 0.5
                },
                sma20: basePrice * (0.98 + Math.random() * 0.04),
                volume: Math.floor(Math.random() * 1000000),
                high: basePrice + Math.random() * 2,
                low: basePrice - Math.random() * 2,
                open: basePrice + (Math.random() - 0.5) * 1
            };
        }

        function updateMultiTimeframeIndicators(primaryData) {
            indicators = primaryData;

            # Update primary price display
            document.getElementById('currentPrice').textContent = '

        function updateChart() {
            var currentSymbolData = priceData[currentTicker];
            if (!currentSymbolData || currentSymbolData.length === 0) return;

            var canvas = document.getElementById('priceChart');
            var ctx = canvas.getContext('2d');

            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (currentSymbolData.length < 2) return;

            var prices = currentSymbolData.map(function(d) { return d.price; });
            var minPrice = Math.min.apply(Math, prices);
            var maxPrice = Math.max.apply(Math, prices);
            var priceRange = maxPrice - minPrice || 1;

            ctx.strokeStyle = '#4facfe';
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (var i = 0; i < currentSymbolData.length; i++) {
                var x = (i / (currentSymbolData.length - 1)) * canvas.width;
                var y = canvas.height - ((currentSymbolData[i].price - minPrice) / priceRange) * canvas.height;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.stroke();

            # Add timeframe indicator
            ctx.fillStyle = '#4facfe';
            ctx.font = '12px Arial';
            ctx.fillText('Timeframe: ' + currentTimeframe, 10, 20);
        }

        function executeTrade(action) {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!isConnected) {
                alert('API connection lost');
                return;
            }

            var quantity = parseInt(document.getElementById('quantity').value);
            var currentPrice = indicators.currentPrice || 100;

            var orderData = {
                symbol: currentTicker,
                action: action.toUpperCase(),
                quantity: quantity,
                orderType: 'MARKET',
                timeInForce: 'DAY',
                price: currentPrice
            };

            fetch(API_BASE_URL + '/api/orders', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(orderData)
            })
            .then(function(response) {
                return response.json();
            })
            .then(function(result) {
                if (result.success) {
                    addLog(action.toUpperCase() + ' order executed: ' + quantity + ' shares at $' + currentPrice.toFixed(2), 'success');

                    var trade = {
                        id: Date.now(),
                        symbol: currentTicker,
                        action: action.toUpperCase(),
                        quantity: quantity,
                        entryPrice: currentPrice,
                        timestamp: new Date(),
                        status: 'OPEN'
                    };

                    if (action.toUpperCase() === 'BUY') {
                        activeTrades.push(trade);
                    } else {
                        var existingTrade = null;
                        for (var i = 0; i < activeTrades.length; i++) {
                            if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                                existingTrade = activeTrades[i];
                                break;
                            }
                        }

                        if (existingTrade) {
                            existingTrade.status = 'CLOSED';
                            existingTrade.exitPrice = currentPrice;
                            var profit = (currentPrice - existingTrade.entryPrice) * existingTrade.quantity;
                            realizedPnL += profit;
                            addLog('Position closed: ' + (profit > 0 ? '+' : '') + '$' + profit.toFixed(2), profit > 0 ? 'success' : 'error');
                        }
                    }

                    updateActiveTradesDisplay();
                    updatePnLDisplay();
                    alert(action.toUpperCase() + ' order submitted successfully!');
                } else {
                    throw new Error(result.error);
                }
            })
            .catch(function(error) {
                addLog('Trade failed: ' + error.message, 'error');
                alert('Trade failed: ' + error.message);
            });
        }

        function cancelAllOrders() {
            addLog('All orders cancelled', 'warning');
            alert('All orders cancelled');
        }

        function setStopLoss() {
            var stopLossPercent = document.getElementById('stopLossPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var stopPrice = currentPrice * (1 - stopLossPercent / 100);

            addLog('Stop loss set at $' + stopPrice.toFixed(2), 'warning');
            alert('Stop loss set at $' + stopPrice.toFixed(2));
        }

        function setProfitTarget() {
            var profitTargetPercent = document.getElementById('profitTargetPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var targetPrice = currentPrice * (1 + profitTargetPercent / 100);

            addLog('Profit target set at $' + targetPrice.toFixed(2), 'success');
            alert('Profit target set at $' + targetPrice.toFixed(2));
        }

        function toggleAutomation() {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            isAutoTrading = !isAutoTrading;
            var toggleBtn = document.getElementById('toggleAuto');
            var statusIndicator = document.getElementById('autoStatus');
            var statusText = document.getElementById('autoStatusText');

            if (isAutoTrading) {
                toggleBtn.textContent = 'Stop Auto Trading';
                toggleBtn.className = 'btn btn-danger';
                statusIndicator.className = 'status-indicator status-active';
                statusText.textContent = 'Active';
                addLog('Auto trading started', 'success');

                autoTradingInterval = setInterval(function() {
                    checkTradingSignals();
                }, 30000);

            } else {
                toggleBtn.textContent = 'Start Auto Trading';
                toggleBtn.className = 'btn btn-primary';
                statusIndicator.className = 'status-indicator status-inactive';
                statusText.textContent = 'Inactive';
                addLog('Auto trading stopped', 'warning');

                if (autoTradingInterval) {
                    clearInterval(autoTradingInterval);
                    autoTradingInterval = null;
                }
            }
        }

        function loadStrategy() {
            var strategyCode = document.getElementById('customScript').value.trim();
            if (!strategyCode) {
                alert('Please enter a strategy first');
                return;
            }

            customStrategy = strategyCode;
            addLog('Strategy loaded', 'success');
            alert('Strategy loaded successfully!');
        }

        function testStrategy() {
            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            if (!indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            try {
                var result = evaluateCustomStrategy(indicators);
                addLog('Strategy test result: ' + result, 'info');
                alert('Strategy test result: ' + result);
            } catch (error) {
                addLog('Strategy test failed', 'error');
                alert('Strategy test failed');
            }
        }

        function clearStrategy() {
            customStrategy = '';
            document.getElementById('customScript').value = '';
            addLog('Strategy cleared', 'info');
        }

        function evaluateMultiTimeframeStrategy(timeframeData, strategy) {
            if (!strategy) return 'N/A';

            try {
                # Extract data from all timeframes
                var data_1m = timeframeData['1m'] || {};
                var data_5m = timeframeData['5m'] || {};
                var data_15m = timeframeData['15m'] || {};
                var data_4h = timeframeData['4h'] || {};

                # Convert ThinkOrSwim multi-timeframe syntax to JavaScript
                var jsCode = strategy
                    # Handle aggregationPeriod references
                    .replace(/RSI\(length\s*=\s*(\d+),\s*aggregationPeriod\s*=\s*AggregationPeriod\.MIN\)/g, function(match, length) {
                        return data_1m.rsi || 50;
                    })
                    .replace(/RSI\(length\s*=\s*(\d+),\s*aggregationPeriod\s*=\s*AggregationPeriod\.FIVE_MIN\)/g, function(match, length) {
                        return data_5m.rsi || 50;
                    })
                    .replace(/RSI\(length\s*=\s*(\d+),\s*aggregationPeriod\s*=\s*AggregationPeriod\.FIFTEEN_MIN\)/g, function(match, length) {
                        return data_15m.rsi || 50;
                    })
                    .replace(/RSI\(length\s*=\s*(\d+),\s*aggregationPeriod\s*=\s*AggregationPeriod\.FOUR_HOURS\)/g, function(match, length) {
                        return data_4h.rsi || 50;
                    })

                    # Handle MACD with timeframes
                    .replace(/MACD\(aggregationPeriod\s*=\s*AggregationPeriod\.MIN\)/g, function() {
                        var macd = data_1m.macd || {macd: 0, signal: 0};
                        return '{Value: ' + macd.macd + ', Avg: ' + macd.signal + '}';
                    })
                    .replace(/MACD\(aggregationPeriod\s*=\s*AggregationPeriod\.FIFTEEN_MIN\)/g, function() {
                        var macd = data_15m.macd || {macd: 0, signal: 0};
                        return '{Value: ' + macd.macd + ', Avg: ' + macd.signal + '}';
                    })

                    # Handle Average (SMA) with timeframes
                    .replace(/Average\(close,\s*(\d+),\s*aggregationPeriod\s*=\s*AggregationPeriod\.FOUR_HOURS\)/g, function(match, period) {
                        return data_4h.sma20 || data_4h.currentPrice || 100;
                    })

                    # Handle def statements
                    .replace(/def\s+(\w+)\s*=/g, 'var $1 =')

                    # Handle basic price references
                    .replace(/\bclose\b/g, data_1m.currentPrice || 100)
                    .replace(/\bhigh\b/g, data_1m.high || data_1m.currentPrice || 100)
                    .replace(/\blow\b/g, data_1m.low || data_1m.currentPrice || 100)
                    .replace(/\bvolume\b/g, data_1m.volume || 0)

                    # Handle logical operators
                    .replace(/\band\b/g, '&&')
                    .replace(/\bor\b/g, '||')
                    .replace(/\bnot\b/g, '!')

                    # Remove comments (only # comments as per your note)
                    .replace(/#.*$/gm, '')
                    .replace(/\s+/g, ' ')
                    .trim();

                # Look for BUY_CONDITION and SELL_CONDITION
                var lines = jsCode.split(';');
                var buyCondition = false;
                var sellCondition = false;

                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i].trim();
                    if (line.indexOf('BUY_CONDITION') !== -1) {
                        # Extract and evaluate buy condition
                        var condition = line.split('=')[1];
                        if (condition) {
                            try {
                                buyCondition = eval(condition.trim());
                            } catch (e) {
                                buyCondition = evaluateConditionPatterns(condition, timeframeData);
                            }
                        }
                    }
                    if (line.indexOf('SELL_CONDITION') !== -1) {
                        # Extract and evaluate sell condition
                        var condition = line.split('=')[1];
                        if (condition) {
                            try {
                                sellCondition = eval(condition.trim());
                            } catch (e) {
                                sellCondition = evaluateConditionPatterns(condition, timeframeData);
                            }
                        }
                    }
                }

                # Return signal based on conditions
                if (buyCondition) return 'BUY';
                if (sellCondition) return 'SELL';
                return 'HOLD';

            } catch (error) {
                console.log('Multi-timeframe strategy evaluation error:', error);
                return 'ERROR';
            }
        }

        function evaluateConditionPatterns(condition, timeframeData) {
            # Pattern matching for complex multi-timeframe conditions
            var data_1m = timeframeData['1m'] || {};
            var data_5m = timeframeData['5m'] || {};
            var data_15m = timeframeData['15m'] || {};
            var data_4h = timeframeData['4h'] || {};

            # Check for trend alignment
            if (condition.indexOf('trend_bullish') !== -1) {
                var currentPrice = data_1m.currentPrice || 100;
                var sma20_4h = data_4h.sma20 || currentPrice;
                return currentPrice > sma20_4h;
            }

            # Check for momentum conditions
            if (condition.indexOf('momentum') !== -1) {
                var macd_15m = data_15m.macd || {macd: 0, signal: 0};
                return macd_15m.macd > macd_15m.signal;
            }

            # Check for oversold conditions
            if (condition.indexOf('oversold') !== -1) {
                return (data_5m.rsi || 50) < 30;
            }

            # Check for entry conditions
            if (condition.indexOf('entry') !== -1) {
                return (data_1m.rsi || 50) < 25;
            }

            return false;
        }

        function checkTradingSignals() {
            if (!isAutoTrading || !currentTicker || !customStrategy) return;

            try {
                # Use multi-timeframe evaluation
                var signal = evaluateMultiTimeframeStrategy(multiTimeframeData, customStrategy);

                if (signal === 'BUY' || signal === 'SELL') {
                    addLog('Multi-timeframe auto signal: ' + signal + ' for ' + currentTicker, 'info');

                    var hasPosition = false;
                    for (var i = 0; i < activeTrades.length; i++) {
                        if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                            hasPosition = true;
                            break;
                        }
                    }

                    if (signal === 'BUY' && !hasPosition) {
                        addLog('Multi-timeframe BUY signal confirmed across timeframes', 'success');
                        executeTrade('buy');
                    } else if (signal === 'SELL' && hasPosition) {
                        addLog('Multi-timeframe SELL signal confirmed across timeframes', 'warning');
                        executeTrade('sell');
                    }
                }
            } catch (error) {
                addLog('Multi-timeframe signal check failed: ' + error.message, 'error');
            }
        }
                     + primaryData.currentPrice.toFixed(2);
            document.getElementById('volume').textContent = (primaryData.volume || 0).toLocaleString();

            # Update multi-timeframe RSI indicators
            if (multiTimeframeData['1m']) {
                document.getElementById('rsi_1m').textContent = (multiTimeframeData['1m'].rsi || 0).toFixed(2);
            }
            if (multiTimeframeData['5m']) {
                document.getElementById('rsi_5m').textContent = (multiTimeframeData['5m'].rsi || 0).toFixed(2);
            }
            if (multiTimeframeData['15m']) {
                document.getElementById('rsi_15m').textContent = (multiTimeframeData['15m'].rsi || 0).toFixed(2);
            }

            # Update multi-timeframe MACD indicators
            if (multiTimeframeData['1m'] && multiTimeframeData['1m'].macd) {
                document.getElementById('macd_1m').textContent = multiTimeframeData['1m'].macd.macd.toFixed(4);
            }
            if (multiTimeframeData['15m'] && multiTimeframeData['15m'].macd) {
                document.getElementById('macd_15m').textContent = multiTimeframeData['15m'].macd.macd.toFixed(4);
            }

            # Update 4-hour SMA
            if (multiTimeframeData['4h']) {
                document.getElementById('sma20_4h').textContent = '

        function updateChart() {
            if (priceData.length === 0) return;

            var canvas = document.getElementById('priceChart');
            var ctx = canvas.getContext('2d');

            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (priceData.length < 2) return;

            var prices = priceData.map(function(d) { return d.price; });
            var minPrice = Math.min.apply(Math, prices);
            var maxPrice = Math.max.apply(Math, prices);
            var priceRange = maxPrice - minPrice || 1;

            ctx.strokeStyle = '#4facfe';
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (var i = 0; i < priceData.length; i++) {
                var x = (i / (priceData.length - 1)) * canvas.width;
                var y = canvas.height - ((priceData[i].price - minPrice) / priceRange) * canvas.height;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.stroke();
        }

        function executeTrade(action) {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!isConnected) {
                alert('API connection lost');
                return;
            }

            var quantity = parseInt(document.getElementById('quantity').value);
            var currentPrice = indicators.currentPrice || 100;

            var orderData = {
                symbol: currentTicker,
                action: action.toUpperCase(),
                quantity: quantity,
                orderType: 'MARKET',
                timeInForce: 'DAY',
                price: currentPrice
            };

            fetch(API_BASE_URL + '/api/orders', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(orderData)
            })
            .then(function(response) {
                return response.json();
            })
            .then(function(result) {
                if (result.success) {
                    addLog(action.toUpperCase() + ' order executed: ' + quantity + ' shares at $' + currentPrice.toFixed(2), 'success');

                    var trade = {
                        id: Date.now(),
                        symbol: currentTicker,
                        action: action.toUpperCase(),
                        quantity: quantity,
                        entryPrice: currentPrice,
                        timestamp: new Date(),
                        status: 'OPEN'
                    };

                    if (action.toUpperCase() === 'BUY') {
                        activeTrades.push(trade);
                    } else {
                        var existingTrade = null;
                        for (var i = 0; i < activeTrades.length; i++) {
                            if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                                existingTrade = activeTrades[i];
                                break;
                            }
                        }

                        if (existingTrade) {
                            existingTrade.status = 'CLOSED';
                            existingTrade.exitPrice = currentPrice;
                            var profit = (currentPrice - existingTrade.entryPrice) * existingTrade.quantity;
                            realizedPnL += profit;
                            addLog('Position closed: ' + (profit > 0 ? '+' : '') + '$' + profit.toFixed(2), profit > 0 ? 'success' : 'error');
                        }
                    }

                    updateActiveTradesDisplay();
                    updatePnLDisplay();
                    alert(action.toUpperCase() + ' order submitted successfully!');
                } else {
                    throw new Error(result.error);
                }
            })
            .catch(function(error) {
                addLog('Trade failed: ' + error.message, 'error');
                alert('Trade failed: ' + error.message);
            });
        }

        function cancelAllOrders() {
            addLog('All orders cancelled', 'warning');
            alert('All orders cancelled');
        }

        function setStopLoss() {
            var stopLossPercent = document.getElementById('stopLossPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var stopPrice = currentPrice * (1 - stopLossPercent / 100);

            addLog('Stop loss set at $' + stopPrice.toFixed(2), 'warning');
            alert('Stop loss set at $' + stopPrice.toFixed(2));
        }

        function setProfitTarget() {
            var profitTargetPercent = document.getElementById('profitTargetPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var targetPrice = currentPrice * (1 + profitTargetPercent / 100);

            addLog('Profit target set at $' + targetPrice.toFixed(2), 'success');
            alert('Profit target set at $' + targetPrice.toFixed(2));
        }

        function toggleAutomation() {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            isAutoTrading = !isAutoTrading;
            var toggleBtn = document.getElementById('toggleAuto');
            var statusIndicator = document.getElementById('autoStatus');
            var statusText = document.getElementById('autoStatusText');

            if (isAutoTrading) {
                toggleBtn.textContent = 'Stop Auto Trading';
                toggleBtn.className = 'btn btn-danger';
                statusIndicator.className = 'status-indicator status-active';
                statusText.textContent = 'Active';
                addLog('Auto trading started', 'success');

                autoTradingInterval = setInterval(function() {
                    checkTradingSignals();
                }, 30000);

            } else {
                toggleBtn.textContent = 'Start Auto Trading';
                toggleBtn.className = 'btn btn-primary';
                statusIndicator.className = 'status-indicator status-inactive';
                statusText.textContent = 'Inactive';
                addLog('Auto trading stopped', 'warning');

                if (autoTradingInterval) {
                    clearInterval(autoTradingInterval);
                    autoTradingInterval = null;
                }
            }
        }

        function loadStrategy() {
            var strategyCode = document.getElementById('customScript').value.trim();
            if (!strategyCode) {
                alert('Please enter a strategy first');
                return;
            }

            customStrategy = strategyCode;
            addLog('Strategy loaded', 'success');
            alert('Strategy loaded successfully!');
        }

        function testStrategy() {
            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            if (!indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            try {
                var result = evaluateCustomStrategy(indicators);
                addLog('Strategy test result: ' + result, 'info');
                alert('Strategy test result: ' + result);
            } catch (error) {
                addLog('Strategy test failed', 'error');
                alert('Strategy test failed');
            }
        }

        function clearStrategy() {
            customStrategy = '';
            document.getElementById('customScript').value = '';
            addLog('Strategy cleared', 'info');
        }

        function evaluateCustomStrategy(data) {
            if (!customStrategy) return 'N/A';

            try {
                var rsi = data.rsi || 50;
                var macd = data.macd ? data.macd.macd : 0;
                var price = data.currentPrice || 100;

                if (customStrategy.indexOf('rsi < 30') !== -1 && rsi < 30) {
                    return 'BUY';
                }
                if (customStrategy.indexOf('rsi > 70') !== -1 && rsi > 70) {
                    return 'SELL';
                }

                return 'HOLD';
            } catch (error) {
                throw new Error('Strategy evaluation failed');
            }
        }

        function checkTradingSignals() {
            if (!isAutoTrading || !currentTicker || !customStrategy) return;

            try {
                var signal = evaluateCustomStrategy(indicators);

                if (signal === 'BUY' || signal === 'SELL') {
                    addLog('Auto signal: ' + signal, 'info');

                    var hasPosition = false;
                    for (var i = 0; i < activeTrades.length; i++) {
                        if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                            hasPosition = true;
                            break;
                        }
                    }
                     + (multiTimeframeData['4h'].sma20 || 0).toFixed(2);
            }

            # Update signal display
            var signal = primaryData.signal || 'HOLD';
            var signalDisplay = document.getElementById('signalDisplay');
            var signalText = document.getElementById('signalText');

            signalText.textContent = signal;
            signalDisplay.className = 'signal-display signal-' + signal.toLowerCase();

            # Evaluate custom multi-timeframe strategy
            if (customStrategy) {
                try {
                    var customResult = evaluateMultiTimeframeStrategy(multiTimeframeData, customStrategy);
                    document.getElementById('customIndicatorValue').textContent = customResult;
                } catch (error) {
                    document.getElementById('customIndicatorValue').textContent = 'Error';
                    addLog('Multi-timeframe strategy error: ' + error.message, 'error');
                }
            }
        }

        function updateChart() {
            if (priceData.length === 0) return;

            var canvas = document.getElementById('priceChart');
            var ctx = canvas.getContext('2d');

            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (priceData.length < 2) return;

            var prices = priceData.map(function(d) { return d.price; });
            var minPrice = Math.min.apply(Math, prices);
            var maxPrice = Math.max.apply(Math, prices);
            var priceRange = maxPrice - minPrice || 1;

            ctx.strokeStyle = '#4facfe';
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (var i = 0; i < priceData.length; i++) {
                var x = (i / (priceData.length - 1)) * canvas.width;
                var y = canvas.height - ((priceData[i].price - minPrice) / priceRange) * canvas.height;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.stroke();
        }

        function executeTrade(action) {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!isConnected) {
                alert('API connection lost');
                return;
            }

            var quantity = parseInt(document.getElementById('quantity').value);
            var currentPrice = indicators.currentPrice || 100;

            var orderData = {
                symbol: currentTicker,
                action: action.toUpperCase(),
                quantity: quantity,
                orderType: 'MARKET',
                timeInForce: 'DAY',
                price: currentPrice
            };

            fetch(API_BASE_URL + '/api/orders', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(orderData)
            })
            .then(function(response) {
                return response.json();
            })
            .then(function(result) {
                if (result.success) {
                    addLog(action.toUpperCase() + ' order executed: ' + quantity + ' shares at $' + currentPrice.toFixed(2), 'success');

                    var trade = {
                        id: Date.now(),
                        symbol: currentTicker,
                        action: action.toUpperCase(),
                        quantity: quantity,
                        entryPrice: currentPrice,
                        timestamp: new Date(),
                        status: 'OPEN'
                    };

                    if (action.toUpperCase() === 'BUY') {
                        activeTrades.push(trade);
                    } else {
                        var existingTrade = null;
                        for (var i = 0; i < activeTrades.length; i++) {
                            if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                                existingTrade = activeTrades[i];
                                break;
                            }
                        }

                        if (existingTrade) {
                            existingTrade.status = 'CLOSED';
                            existingTrade.exitPrice = currentPrice;
                            var profit = (currentPrice - existingTrade.entryPrice) * existingTrade.quantity;
                            realizedPnL += profit;
                            addLog('Position closed: ' + (profit > 0 ? '+' : '') + '$' + profit.toFixed(2), profit > 0 ? 'success' : 'error');
                        }
                    }

                    updateActiveTradesDisplay();
                    updatePnLDisplay();
                    alert(action.toUpperCase() + ' order submitted successfully!');
                } else {
                    throw new Error(result.error);
                }
            })
            .catch(function(error) {
                addLog('Trade failed: ' + error.message, 'error');
                alert('Trade failed: ' + error.message);
            });
        }

        function cancelAllOrders() {
            addLog('All orders cancelled', 'warning');
            alert('All orders cancelled');
        }

        function setStopLoss() {
            var stopLossPercent = document.getElementById('stopLossPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var stopPrice = currentPrice * (1 - stopLossPercent / 100);

            addLog('Stop loss set at $' + stopPrice.toFixed(2), 'warning');
            alert('Stop loss set at $' + stopPrice.toFixed(2));
        }

        function setProfitTarget() {
            var profitTargetPercent = document.getElementById('profitTargetPercent').value;
            if (!currentTicker || !indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            var currentPrice = indicators.currentPrice;
            var targetPrice = currentPrice * (1 + profitTargetPercent / 100);

            addLog('Profit target set at $' + targetPrice.toFixed(2), 'success');
            alert('Profit target set at $' + targetPrice.toFixed(2));
        }

        function toggleAutomation() {
            if (!currentTicker) {
                alert('Please select a ticker first');
                return;
            }

            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            isAutoTrading = !isAutoTrading;
            var toggleBtn = document.getElementById('toggleAuto');
            var statusIndicator = document.getElementById('autoStatus');
            var statusText = document.getElementById('autoStatusText');

            if (isAutoTrading) {
                toggleBtn.textContent = 'Stop Auto Trading';
                toggleBtn.className = 'btn btn-danger';
                statusIndicator.className = 'status-indicator status-active';
                statusText.textContent = 'Active';
                addLog('Auto trading started', 'success');

                autoTradingInterval = setInterval(function() {
                    checkTradingSignals();
                }, 30000);

            } else {
                toggleBtn.textContent = 'Start Auto Trading';
                toggleBtn.className = 'btn btn-primary';
                statusIndicator.className = 'status-indicator status-inactive';
                statusText.textContent = 'Inactive';
                addLog('Auto trading stopped', 'warning');

                if (autoTradingInterval) {
                    clearInterval(autoTradingInterval);
                    autoTradingInterval = null;
                }
            }
        }

        function loadStrategy() {
            var strategyCode = document.getElementById('customScript').value.trim();
            if (!strategyCode) {
                alert('Please enter a strategy first');
                return;
            }

            customStrategy = strategyCode;
            addLog('Strategy loaded', 'success');
            alert('Strategy loaded successfully!');
        }

        function testStrategy() {
            if (!customStrategy) {
                alert('Please load a strategy first');
                return;
            }

            if (!indicators.currentPrice) {
                alert('Please select a ticker first');
                return;
            }

            try {
                var result = evaluateCustomStrategy(indicators);
                addLog('Strategy test result: ' + result, 'info');
                alert('Strategy test result: ' + result);
            } catch (error) {
                addLog('Strategy test failed', 'error');
                alert('Strategy test failed');
            }
        }

        function clearStrategy() {
            customStrategy = '';
            document.getElementById('customScript').value = '';
            addLog('Strategy cleared', 'info');
        }

        function evaluateCustomStrategy(data) {
            if (!customStrategy) return 'N/A';

            try {
                var rsi = data.rsi || 50;
                var macd = data.macd ? data.macd.macd : 0;
                var price = data.currentPrice || 100;

                if (customStrategy.indexOf('rsi < 30') !== -1 && rsi < 30) {
                    return 'BUY';
                }
                if (customStrategy.indexOf('rsi > 70') !== -1 && rsi > 70) {
                    return 'SELL';
                }

                return 'HOLD';
            } catch (error) {
                throw new Error('Strategy evaluation failed');
            }
        }

        function checkTradingSignals() {
            if (!isAutoTrading || !currentTicker || !customStrategy) return;

            try {
                var signal = evaluateCustomStrategy(indicators);

                if (signal === 'BUY' || signal === 'SELL') {
                    addLog('Auto signal: ' + signal, 'info');

                    var hasPosition = false;
                    for (var i = 0; i < activeTrades.length; i++) {
                        if (activeTrades[i].symbol === currentTicker && activeTrades[i].status === 'OPEN') {
                            hasPosition = true;
                            break;
                        }
                    }